<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Tadpole Trials 2 - 1st Rank Biology</title>
  <link rel="icon" href="https://svkhhnulgictmdvqvwte.supabase.co/storage/v1/object/public/favicon//favicon.png" type="image/png">
  <meta name="description" content="Play Tadpole Trials 2 ‚Äì a fun, fast-paced biology revision platformer! Collect and answer questions across 10 levels and help Tadpole get home.">
  <!-- Open Graph Meta Tags for Social Sharing -->
<meta property="og:title" content="Tadpole Trials 2 ‚Äì A Biology Revision Game">
<meta property="og:description" content="A fun biology revision platformer. Collect brains, answer questions, and help Tadpole make it home!">
<meta property="og:image" content="https://svkhhnulgictmdvqvwte.supabase.co/storage/v1/object/public/Tadpole%20Trials%202/Tadpole%20Trials%202%20Social.png">
<meta property="og:url" content="https://tadpoletrials.1strankbiology.com">
<meta property="og:type" content="website">

<!-- Twitter Card Meta Tags -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Tadpole Trials 2 ‚Äì A Biology Revision Game">
<meta name="twitter:description" content="Collect and answer biology questions in this fun platformer. Can you help Tadpole get home?">
<meta name="twitter:image" content="https://svkhhnulgictmdvqvwte.supabase.co/storage/v1/object/public/Tadpole%20Trials%202/Tadpole%20Trials%202%20Social.png">

  <style>
    /* Logo link styles */
header a {
  display: block;
  text-decoration: none;
  border: none;
  outline: none;
}

/* Add hover effect */
header a:hover {
  opacity: 0.9;
  transform: scale(1.01);
  transition: transform 0.2s ease;
}

.logo {
  max-width: 200px;
  width: 100%;
  height: auto;
  margin: 0 auto 10px;
  display: block;
}
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      touch-action: manipulation;
    }
    
    body {
      background: linear-gradient(135deg, #1a2a6c, #b21f1f, #1a2a6c);
      color: white;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 10px;
      overflow-x: hidden;
    }
    
    header {
      text-align: center;
      margin-bottom: 10px;
      width: 100%;
      max-width: 800px;
      padding-top: 5px;
    }

    
    h1 {
      font-size: 2.5rem;
      margin-bottom: 5px;
      text-shadow: 0 0 15px rgba(127, 216, 255, 0.7);
      position: relative;
      display: inline-block;
    }
    
    .game-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
      max-width: 800px;
      position: relative;
      overflow: hidden;
      transition: all 0.3s ease;
    }

    /* Default (e.g. start screen, menus) */
    .game-container:not(.game-active) {
      background: rgba(0, 20, 40, 0.85);
      border-radius: 15px;
      padding: 15px;
      box-shadow: 0 0 20px rgba(0, 100, 200, 0.5);
      border: 2px solid #00ccff;
    }

    /* During gameplay: strip visual styles */
    .game-container.game-active {
      background: transparent;
      border: none;
      border-radius: 0;
      padding: 0;
      box-shadow: none;
    }

    
    .screen {
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 15px;
      padding: 15px;
    }
    
    /* Start Screen - Original with small tweaks */
    #startScreen {
      width: 100%;
      max-width: 800px;
      margin: 0 auto;
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    #startCanvas {
      width: 100%;
      height: auto; /* Changed from fixed height */
      min-height: 300px;
      max-height: 400px;
      aspect-ratio: 800/400; /* Maintain original aspect ratio */
      display: block;
    }

    #startBtn {
      margin-top: 20px;
      z-index: 2;
    }

    .controls-info {
      position: absolute;
      bottom: 80px;
      left: 0;
      width: 100%;
      text-align: center;
      color: rgba(255,255,255,0.8);
      font-size: 20px;
      pointer-events: none;
      padding: 0 10px;
      box-sizing: border-box;
    }
    
    #gameCanvas {
      background: linear-gradient(to bottom, #87CEEB, #E0F7FA);
      border: 3px solid #00aaff;
      border-radius: 8px;
      display: block;
      margin: 0 auto;
      box-shadow: 0 0 15px rgba(0, 150, 255, 0.5);
      max-width: 800px;
      width: 100%;
      height: auto;
      image-rendering: pixelated;
      box-sizing: border-box;
    }
    
    #quiz, #scoreScreen, #finalScreen {
      background: rgba(10, 30, 60, 0.9);
      border-radius: 12px;
      padding: 20px;
      width: 100%;
      max-width: 600px;
      text-align: center;
    }
    
    #questionText {
      font-size: 1.2rem;
      margin-bottom: 20px;
      color: #aaffff;
      line-height: 1.4;
    }
    
    .optionBtn {
      width: 100%;
      padding: 12px;
      margin: 8px 0;
      background: linear-gradient(to right, #1e3c72, #2a5298);
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 1rem;
      cursor: pointer;
      transition: all 0.3s ease;
      text-align: left;
      position: relative;
      overflow: hidden;
    }
    
    .optionBtn:active {
      transform: translateY(1px);
    }
    
    .optionBtn:before {
      content: "";
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      width: 5px;
      background: #00ccff;
    }
    
    button {
      background: linear-gradient(to right, #00c6ff, #0072ff);
      color: white;
      border: none;
      padding: 12px 24px;
      font-size: 1.1rem;
      border-radius: 40px;
      cursor: pointer;
      transition: all 0.3s ease;
      margin: 8px;
      box-shadow: 0 4px 12px rgba(0, 100, 200, 0.4);
      font-weight: bold;
      min-width: 140px;
    }
    
    button:active {
      transform: translateY(1px);
    }
    
    .stats {
      display: flex;
      justify-content: space-around;
      width: 100%;
      padding: 12px;
      background: rgba(0, 30, 60, 0.7);
      border-radius: 8px;
      margin-bottom: 15px;
      font-size: 1rem;
      border: 1px solid #00aaff;
      flex-wrap: wrap;
    }
    
    .stats span {
      color: #aaffff;
      font-weight: bold;
    }
    
    .instructions {
      background: rgba(0, 40, 80, 0.7);
      padding: 15px;
      border-radius: 12px;
      margin: 15px 0;
      width: 100%;
      max-width: 600px;
      text-align: center;
      border: 1px solid #00ccff;
    }
    
    .instructions p {
      margin: 8px 0;
      line-height: 1.5;
    }
    
    .key {
      display: inline-block;
      background: rgba(0, 100, 200, 0.5);
      padding: 4px 8px;
      border-radius: 4px;
      margin: 0 4px;
      font-weight: bold;
      border: 1px solid #00aaff;
    }
    
    .brain-counter {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      font-size: 1.1rem;
      margin: 8px 0;
    }


    .quiz-score-pill{
      margin: 8px 0 14px;
      padding: 8px 14px;
      border-radius: 999px;
      background: rgba(0, 100, 200, 0.25);
      border: 1px solid rgba(0, 204, 255, 0.7);
      display: inline-block;
      font-weight: 700;
      color: #aaffff;
    }
    
    .brain-icon {
      color: #ff66cc;
      font-size: 1.5rem;
      animation: pulse 1.5s infinite;
    }
    
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.2); }
      100% { transform: scale(1); }
    }
    
    @keyframes jump {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-15px); }
    }
    
    .level-indicator {
      font-size: 1.2rem;
      margin: 12px 0;
      padding: 8px 16px;
      background: rgba(0, 100, 200, 0.3);
      border-radius: 40px;
      display: inline-block;
      border: 1px solid #00ccff;
    }
    
    .correct {
      background: linear-gradient(to right, #00b09b, #96c93d) !important;
    }
    
    .incorrect {
      background: linear-gradient(to right, #ff416c, #ff4b2b) !important;
    }
    
    .controls {
      display: flex;
      gap: 15px;
      flex-wrap: wrap;
      justify-content: center;
      margin-top: 15px;
    }
    
    .death-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(200, 0, 0, 0.5);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 10;
      opacity: 0;
      pointer-events: none;
    }
    

    /* Intro overlay */
    #introOverlay{
      position:absolute;
      top:0; left:0;
      width:100%; height:100%;
      display:none;
      justify-content:center;
      align-items:center;
      background: rgba(0,0,0,0.65);
      z-index: 20;
      padding: 20px;
      box-sizing: border-box;
    }
    #introOverlay .intro-card{
      max-width: 600px;
      width: 100%;
      background: rgba(10, 30, 60, 0.92);
      border: 2px solid #00ccff;
      border-radius: 12px;
      padding: 18px;
      text-align: center;
      box-shadow: 0 0 20px rgba(0, 150, 255, 0.35);
    }
    #introOverlay .intro-text{
      font-size: 1.15rem;
      line-height: 1.5;
      color: #e6f7ff;
      margin-bottom: 14px;
    }
    #introContinueBtn{
      margin-top: 6px;
    }


    .death-message {
      background: rgba(0, 0, 0, 0.8);
      padding: 15px;
      border-radius: 8px;
      text-align: center;
      font-size: 1.2rem;
    }
    
    /* Mobile Controls */
    #mobileControls {
      display: none;
      position: absolute;
      bottom: 20px;
      width: calc(100% - 30px);
      justify-content: space-between;
      z-index: 5;
      pointer-events: none;
    }

    @media (max-width: 768px) {
      .game-container.game-active #mobileControls {
        display: flex;
      }

      #mobileControls,
      #mobileControls button {
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        touch-action: none;
        -webkit-tap-highlight-color: transparent;
      }
    }


    /* Visibility control */
    @media (max-width: 768px) {
      .game-container.game-active #mobileControls {
        display: flex;
      }
    }
    
    .dpad-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 5px;
    }
    
    .dpad-row {
      display: flex;
      gap: 5px;
    }
    
    .control-btn {
      width: 60px;
      height: 60px;
      background: rgba(0, 0, 0, 0.5);
      border: 2px solid rgba(255, 255, 255, 0.7);
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 24px;
      color: white;
      pointer-events: auto;
      touch-action: manipulation;
      user-select: none;
    }
    
    .jump-btn {
      width: 70px;
      height: 70px;
      background: rgba(0, 100, 200, 0.5);
      border: 2px solid rgba(255, 255, 255, 0.7);
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 16px;
      font-weight: bold;
      color: white;
      pointer-events: auto;
      touch-action: manipulation;
      user-select: none;
      align-self: flex-end;
      margin-right: 10px;
    }
    
    /* New shoot button */
    .shoot-btn {
      width: 70px;
      height: 70px;
      background: rgba(200, 0, 0, 0.5);
      border: 2px solid rgba(255, 255, 255, 0.7);
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 14px;
      font-weight: bold;
      color: white;
      pointer-events: auto;
      align-self: flex-end;
      margin-right: 10px;
      position: absolute;
      right: 10px;
      bottom: 90px;
    }
    
    /* Mobile-specific adjustments */
    @media (max-width: 768px) {
      h1 {
        font-size: 2rem;
      }
      
      h1:after {
        right: -35px;
        font-size: 1.8rem;
      }
      
      .game-container {
        padding: 10px;
        border-radius: 12px;
      }
      
      .screen {
        padding: 10px;
      }
      
      #quiz, #scoreScreen, #finalScreen {
        padding: 15px;
      }
      
      #questionText {
        font-size: 1.1rem;
      }
      
      .optionBtn {
        padding: 10px;
        font-size: 0.95rem;
      }
      
      button {
        padding: 10px 20px;
        font-size: 1rem;
        min-width: 120px;
      }
      
      .stats {
        flex-direction: column;
        gap: 8px;
      }
      
      .controls {
        flex-direction: column;
        gap: 10px;
      }
      
      
      /* Hide up arrow on mobile */
      #upBtn {
        display: none !important;
      }
    }
    
    @media (max-width: 768px) {
      .controls-info {
        display: none !important;
      }
    }


   /* Portrait-specific adjustments */
    @media (max-width: 768px) and (orientation: portrait) {
      #startCanvas {
        min-height: 250px;
      }
      
      h1 {
        font-size: 2rem;
        white-space: nowrap; /* Prevent text wrapping */
      }
      
      .controls-info {
        font-size: 18px;
        bottom: 60px;
      }
    }

    @media (max-width: 480px) and (orientation: portrait) {
      h1 {
        font-size: 1.8rem;
      }
      
      .controls-info {
        font-size: 16px;
      }
    }

    @media (max-width: 480px) {
      h1 {
        font-size: 1.8rem;
      }
      
      h1:after {
        right: -30px;
        font-size: 1.5rem;
      }
      
      .level-indicator {
        font-size: 1rem;
        padding: 6px 12px;
      }
      
      .control-btn {
        width: 50px;
        height: 50px;
        font-size: 20px;
      }
      
      .jump-btn {
        width: 60px;
        height: 60px;
        font-size: 14px;
      }
      
      .shoot-btn {
        width: 60px;
        height: 60px;
        font-size: 12px;
        bottom: 80px;
      }
    }

    /* Character Selection */
    .characters {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin: 20px 0;
      flex-wrap: wrap;
    }
    
    .char-option {
      width: 120px;
      height: 140px;
      background: rgba(0, 50, 100, 0.7);
      border-radius: 10px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.3s ease;
      border: 2px solid transparent;
      padding: 10px;
      text-align: center;
    }
    
    .char-option:hover {
      transform: translateY(-5px);
      background: rgba(0, 80, 160, 0.8);
    }
    
    .char-option.selected {
      border-color: #00ccff;
      box-shadow: 0 0 15px rgba(127, 216, 255, 0.7);
      background: rgba(0, 80, 160, 0.9);
    }
    
    .char-icon {
      font-size: 3rem;
      margin-bottom: 10px;
    }
    
    .char-name {
      font-size: 0.9rem;
      font-weight: bold;
    }
    
    .char-description {
      font-size: 0.8rem;
      margin-top: 5px;
      color: #aaffff;
    }
    
    /* Elemental Effects */
    .water-effect {
      background: linear-gradient(to bottom, #00aaff, #0066cc);
    }
    
    .electric-effect {
      background: linear-gradient(to bottom, #ffff00, #ffaa00);
    }
    
    .fire-effect {
      background: linear-gradient(to bottom, #ff5500, #cc0000);
    }
    
    /* New Platform Styles */
.platform-ice { background: linear-gradient(to bottom, #aaffff, #66ccff); }

.platform-magma { background: linear-gradient(to bottom, #ff6600, #cc3300); }

.platform-green {
  background: linear-gradient(to bottom, #aaffaa, #66cc66); }

/* Dark, readable steel platform */
.platform-dark {
  background:
    /* top light overlay (slightly brighter for readability) */
    linear-gradient(
      to bottom,
      rgba(255,255,255,0.16) 0%,
      rgba(255,255,255,0.06) 30%,
      rgba(0,0,0,0.32) 100%
    ),
    /* steel stripes */
    repeating-linear-gradient(
      45deg,
      #323840 0px,
      #323840 12px,
      #2a2f36 12px,
      #2a2f36 24px
    );
  border: 1px solid #4a525c;
  box-shadow:
    inset 0 3px 0 rgba(255,255,255,0.14),
    inset 0 -3px 0 rgba(0,0,0,0.42),
    0 2px 6px rgba(0,0,0,0.55);
  color: #e6edf3;
  border-radius: 6px;
}
    
    /* New Enemy Styles */
    .enemy-ice {
      background: linear-gradient(to bottom, #88ddff, #3399ff);
    
      border: 2px solid rgba(255,255,255,0.65);
      box-shadow: 0 0 10px rgba(255,255,255,0.25), 0 2px 8px rgba(0,0,0,0.65);
      filter: drop-shadow(0 0 6px rgba(0,0,0,0.55));
    }
    
    .enemy-magma {
      background: linear-gradient(to bottom, #ff8844, #cc5500);
    
      border: 2px solid rgba(255,255,255,0.65);
      box-shadow: 0 0 10px rgba(255,255,255,0.25), 0 2px 8px rgba(0,0,0,0.65);
      filter: drop-shadow(0 0 6px rgba(0,0,0,0.55));
    }
    
    .enemy-nightmare {
      background: linear-gradient(to bottom, #cc88ff, #8844cc);
    
      border: 2px solid rgba(255,255,255,0.65);
      box-shadow: 0 0 10px rgba(255,255,255,0.25), 0 2px 8px rgba(0,0,0,0.65);
      filter: drop-shadow(0 0 6px rgba(0,0,0,0.55));
    }
    
    .enemy-sentinel {
      background: linear-gradient(to bottom, #aaddaa, #66aa66);
    
      border: 2px solid rgba(255,255,255,0.65);
      box-shadow: 0 0 10px rgba(255,255,255,0.25), 0 2px 8px rgba(0,0,0,0.65);
      filter: drop-shadow(0 0 6px rgba(0,0,0,0.55));
    }

    /* Topic Selection */
    .topic-selection {
      margin: 15px 0;
      text-align: center;
    }
    
    .topic-buttons {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
      margin: 15px 0;
    }
    
    .topic-btn {
      background: linear-gradient(to right, #1e3c72, #2a5298);
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 20px;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .topic-btn.active {
      background: linear-gradient(to right, #00b09b, #96c93d);
      box-shadow: 0 0 10px rgba(100, 255, 100, 0.5);
    }
    
    .topic-btn:hover {
      transform: translateY(-2px);
    }
    
    /* Projectile Effects */
    .projectile-water {
      background: radial-gradient(circle, #3fd0ff 0%, #0a63ff 55%, #00308f 100%);
      border: 2px solid rgba(255,255,255,0.75);
      box-shadow: 0 0 14px rgba(63,208,255,0.55), 0 2px 8px rgba(0,0,0,0.55);
    }
    
    .projectile-electric {
      background: radial-gradient(circle, #ffff00, #ffaa00);
      animation: electric-pulse 0.5s infinite;
    }
    
    .projectile-fire {
      background: radial-gradient(circle, #ff5500, #cc0000);
      animation: fire-pulse 0.5s infinite;
    }
    
    @keyframes electric-pulse {
      0% { box-shadow: 0 0 5px #ffff00; }
      50% { box-shadow: 0 0 15px #ffff00; }
      100% { box-shadow: 0 0 5px #ffff00; }
    }
    
    @keyframes fire-pulse {
      0% { box-shadow: 0 0 5px #ff5500; }
      50% { box-shadow: 0 0 15px #ff5500; }
      100% { box-shadow: 0 0 5px #ff5500; }
    }
  
    .sound-toggle{
  position:absolute;
  bottom:14px;
  right:14px;
  width:34px;
  height:34px;
  border-radius:50%;
  display:flex;
  align-items:center;
  justify-content:center;
  padding:0;
  font-size:16px;
  line-height:1;
  background:rgba(10,30,60,0.55);
  border:1px solid rgba(255,255,255,0.18);
  color:#fff;
  box-shadow:0 6px 16px rgba(0,0,0,0.22);
  opacity:0.78;
  z-index:60;
}
.sound-toggle:hover{opacity:1;}
.sound-toggle:active{ transform:scale(0.98); }

/* Sound toggle mobile offset */
@media (max-width: 700px){
  .sound-toggle{
    bottom: 110px; /* above on-screen controls */
  }
}

.sound-toggle:hover{ opacity:0.95; }
.sound-toggle:active{ transform: translateY(1px); }

/* =========================
   Mobile portrait layout polish
   - Controls move BELOW the game canvas
   - Mute button moves BELOW canvas (separate bar) to avoid accidental taps
   ========================= */

/* Only show the bar during gameplay */
.game-container.game-active .mobile-hud-bar{
  display:flex;
}

.mobile-hud-bar{
  display:none;
  width: 100%;
  max-width: 800px;
  margin: 10px auto 0;
  justify-content: flex-end;
  gap: 10px;
  padding: 0 6px;
  box-sizing: border-box;
}

/* Portrait phones: place on-screen controls underneath the canvas */
@media (max-width: 768px) and (orientation: portrait){
  /* Sound button becomes part of the bar (no absolute positioning) */
  .sound-toggle{
    position: static !important;
    bottom: auto !important;
    right: auto !important;
    width: 44px;
    height: 44px;
    font-size: 18px;
    opacity: 0.9;
  }

  /* Controls sit below the canvas */
  #mobileControls{
    position: static !important;
    width: 100% !important;
    margin: 10px auto 0 !important;
    padding: 10px 8px 8px !important;
    pointer-events: auto !important;
    box-sizing: border-box;
    gap: 14px;
  }

  /* Keep buttons in natural flow (no absolute shoot button) */
  .shoot-btn{
    position: static !important;
    right: auto !important;
    bottom: auto !important;
    margin-right: 0 !important;
    align-self: auto !important;
  }
  .jump-btn{
    margin-right: 0 !important;
    align-self: auto !important;
  }

  .right-controls{
    display:flex;
    flex-direction: column;
    align-items: flex-end;
    gap: 10px;
  }
}


    /* Mobile: keep character options side-by-side */
    @media (max-width: 520px) {
      .characters{
        gap: 10px;
        flex-wrap: nowrap;
      }
      .char-option{
        width: 95px;
        height: 120px;
        padding: 8px;
      }
      .char-icon{
        font-size: 2.2rem;
        margin-bottom: 6px;
      }
      .char-name{
        font-size: 0.85rem;
      }
      .char-description{
        font-size: 0.7rem;
        margin-top: 4px;
      }
    }

  </style>
</head>
<body>
<!-- Responsive Game Banner + Footer Branding -->
<style>

  /* Banner matches game canvas width (800px) without distortion.
     Polished for different screens + safe-area support. */
  #tt2-banner-container{
    width: 100%;
    max-width: 800px; /* match #gameCanvas max width */
    margin: 0 auto 12px;

    /* Mobile notch / safe-area padding */
    padding-left: env(safe-area-inset-left);
    padding-right: env(safe-area-inset-right);

    /* A little polish */
    border-radius: 14px;
    overflow: hidden;
    box-shadow: 0 10px 26px rgba(0,0,0,0.20);
  }

  /* Keep image crisp + uncropped on all devices */
  #tt2-banner-container img{
    width: 100%;
    height: auto;
    display: block;
    object-fit: contain; /* no cropping */
  }

  /* Slightly tighter on very small screens */
  @media (max-width: 480px){
    #tt2-banner-container{
      margin-bottom: 10px;
      border-radius: 12px;
      box-shadow: 0 8px 20px rgba(0,0,0,0.18);
    }
  }

  /* Footer logo */
  #tt2-footer{
    width: 100%;
    max-width: 800px;
    margin: 14px auto 6px;
    padding: 10px 0 6px;
    text-align: center;

    /* Safe-area padding */
    padding-left: env(safe-area-inset-left);
    padding-right: env(safe-area-inset-right);
  }

  #tt2-footer a{
    display: inline-block;
    text-decoration: none;
    border: none;
    outline: none;
  }

  #tt2-footer a:hover{
    opacity: 0.9;
    transform: scale(1.01);
    transition: transform 0.2s ease;
  }

  #tt2-footer img{
    height: 42px;
    width: auto;
    display: inline-block;
  }

</style>

<div id="tt2-banner-container">
    <img src="https://svkhhnulgictmdvqvwte.supabase.co/storage/v1/object/public/Tadpole%20Trials%202/TadpoleTrials2%20Banner2.png" alt="Tadpole Trials 2 Banner" loading="eager">
</div>

  
  
  <p class="level-indicator" style="display:none;"></p>
<div class="game-container">
<div id="startScreen" class="screen">
      <canvas id="startCanvas"></canvas>
      
      <div id="characterSelection">
        <h3>Choose Your Tadpole</h3>
        <div class="characters">
          <div class="char-option" data-char="water">
            <div class="char-icon">üíß</div>
            <div class="char-name">Bubbles</div>
          </div>
          <div class="char-option" data-char="electric">
            <div class="char-icon">‚ö°</div>
            <div class="char-name">Spark</div>
          </div>
          <div class="char-option" data-char="fire">
            <div class="char-icon">üî•</div>
            <div class="char-name">Flame</div>
          </div>
        </div>
        
        <div class="topic-selection">
          <h3>Select Study Topic</h3>
          <div class="topic-buttons">
            <button class="topic-btn active" data-topic="trivia">Biology Trivia</button>
<button class="topic-btn" data-topic="vce">VCE Biology</button>
</div>
        </div>
<div class="controls-info">‚Üê ‚Üí to move ‚Ä¢ SPACE to jump ‚Ä¢ F/SHOOT to fire</div>
        <button id="startBtn">Start Game</button>
      </div>
    </div>


    <!-- Simple Intro Overlay (shown once at game start) -->
    <div id="introOverlay" style="display:none;">
      <div class="intro-card">
        <div class="intro-text">
          A powerful storm scattered Tadpole and his homework across distant lands.<br>
          Help him travel home and collect every lost question along the way.
        </div>
        <button id="introContinueBtn">Continue</button>
      </div>
    </div>

    <!-- Game Canvas & Overlay -->
    <canvas id="gameCanvas" width="800" height="400"></canvas>

    <div id="mobileHudBar" class="mobile-hud-bar">
      <button id="soundToggle" class="sound-toggle" aria-label="Toggle sound" title="Sound on/off">üîä</button>
    </div>
    <div id="deathOverlay" class="death-overlay">
      <div class="death-message">Oh no! Press R to respawn</div>
    </div>

    <div id="mobileControls">
      <div class="left-controls">
        <div class="dpad-container">
          <div class="dpad-row">
            <div class="control-btn" id="upBtn">‚Üë</div>
          </div>
          <div class="dpad-row">
            <div class="control-btn" id="leftBtn">‚Üê</div>
            <div class="control-btn" id="downBtn" style="visibility: hidden;"></div>
            <div class="control-btn" id="rightBtn">‚Üí</div>
          </div>
        </div>
      </div>

      <div class="right-controls">
        <div class="shoot-btn" id="shootBtn">SHOOT</div>
        <div class="jump-btn" id="jumpBtn">JUMP</div>
      </div>
    </div>

    <!-- Quiz Screen -->
    <div id="quiz" class="screen">
      <h2>Biology Quiz</h2>
      <div class="brain-counter">
        <span class="brain-icon">üß†</span> 
        <span id="collectedCount">0</span> Collected
      </div>
      <div class="quiz-score-pill">üèÜ Score: <span id="pointsDisplayQuiz">0</span></div>
      <h3 id="questionText"></h3>
      <div id="optionsContainer"></div>
    </div>

    <!-- Score Screen -->
    <div id="scoreScreen" class="screen">
      <h2>Level Complete! üéâ</h2>
      <h3 id="scoreSummary"></h3>
      <div class="controls">
        <button id="retryBtn">üîÅ Retry Level</button>
        <button id="nextBtn">‚û° Next Level</button>
      </div>
    </div>

    <!-- Final Screen -->
    <div id="finalScreen" class="screen">
      <h2>Congratulations!</h2>
      <div id="reunionRow" style="font-size: 3rem; margin: 6px 0 10px; letter-spacing: 8px;">üíß ‚ö° üî•</div>
      <h3 id="finalText"></h3>
      <div style="display:flex; gap:10px; justify-content:center; flex-wrap:wrap; margin-top:12px;">
        <button id="shareBtn">Beat My Score</button>
        <button id="restartBtn">Play Again</button>
      </div>
    </div>
  </div>

  <script>
    // Mobile detection
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    
    // Game state with enhanced physics and enemies
    const gameState = {
  npc: null,
currentLevel: 1,
  levels: [
    { name: "Lost: Wild Storm", questions: 5, collected: 0, brains: 5 },               // Wild Storm
    { name: "Snow Forest", questions: 5, collected: 0, brains: 5 },             // First expansion
    { name: "Caves", questions: 5, collected: 0, brains: 5 },              // Underground challenge
    { name: "Haunted Swamp",    questions: 5, collected: 0, brains: 5 },
    { name: "Rainy Forest", questions: 5, collected: 0, brains: 5 },      // Early spooky twist
    { name: "Lake", questions: 5, collected: 0, brains: 5 },      // Cold and slippery
    { name: "City", questions: 5, collected: 0, brains: 5 },        // Airborne challenge
    { name: "City Ruins", questions: 5, collected: 0, brains: 5 },         // Civilization aftermath
    { name: "Alien World", questions: 5, collected: 0, brains: 5 },            // Fire and chaos
    { name: "Pond: Coming Home", questions: 5, collected: 0, brains: 5 }              // Final showdown
  ],
      player: {
        x: 100,
        y: 300,
        width: 30,
        height: 30,
        velX: 0,
        velY: 0,
        speed: isMobile ? 5.0 : 3.5,
        jumpPower: -12,
        gravity: 0.5,
        friction: 0.8,
        jumping: false,
        direction: 1,
        grounded: false,
        lives: 3,
        element: "water" // Default element
      ,
        standingOn: null // moving platform currently standing on
      },
      platforms: [],
      brains: [],
      enemies: [],
      playerProjectiles: [],
      enemyProjectiles: [],
      particles: [],
      zaps: [],
      splashes: [], 
      shootCooldown: 0,
      endFlag: null,
      collectedBrains: [],
      quizQuestions: [],
      usedQuestions: [],
      currentQuestion: 0,
      score: {
        correct: 0,
        total: 0
      },
      levelScore: {
        correct: 0,
        total: 0
      },
      overall: {
        correct: 0,
        total: 50
      },
      keys: {
        left: false,
        right: false,
        up: false,
        r: false,
        shoot: false
      },
      gameActive: false,
      cameraX: 0,
      levelWidth: 2000,
      isDead: false,
      selectedTopic: "trivia", // Default topic
      introShown: false,
      points: 0,
      levelPoints: 0,
      levelStartPoints: 0
    };

    // DOM elements

// =========================
// Scoring (simple + safe)
// =========================
const SCORE = {
  brain: 10,
  enemy: 25,
  correct: 100,
  noDeathBonus: 250,
  surviveMultiplierPerLife: 0.25, // +25% per extra life (3 lives => 1.5x)
  wipeKeep: 0.5                  // keep 50% of points earned this level if you wipe
};

function livesMultiplier(){
  const lives = gameState.player?.lives ?? 1;
  return 1 + Math.max(0, lives - 1) * SCORE.surviveMultiplierPerLife; // 1.0, 1.25, 1.5
}

function addPoints(base){
  const gained = Math.round(base * livesMultiplier());
  gameState.points += gained;
  gameState.levelPoints += gained;
  updatePointsUI();
  return gained;
}

function updatePointsUI(){
  // Only update if the element exists (quiz screen)
  if (pointsDisplayQuiz) pointsDisplayQuiz.textContent = gameState.points;
}

function startLevelScoring(){
  gameState.levelStartPoints = gameState.points;
  gameState.levelPoints = 0;
}

function applyWipePenalty(){
  // Halve the points earned this level (keep 50%) without affecting previous levels
  const earned = gameState.points - gameState.levelStartPoints;
  const kept = Math.floor(Math.max(0, earned) * SCORE.wipeKeep);
  gameState.points = gameState.levelStartPoints + kept;
  gameState.levelPoints = kept;
}

    const startScreen = document.getElementById('startScreen');
    const gameCanvas = document.getElementById('gameCanvas');
    const quizScreen = document.getElementById('quiz');
    const soundToggle = document.getElementById('soundToggle');
    const scoreScreen = document.getElementById('scoreScreen');
    const finalScreen = document.getElementById('finalScreen');
    const startBtn = document.getElementById('startBtn');
    const retryBtn = document.getElementById('retryBtn');
    const nextBtn = document.getElementById('nextBtn');
    const restartBtn = document.getElementById('restartBtn');

const shareBtn = document.getElementById('shareBtn');

function getModeLabel(){
  return (gameState.selectedTopic === "vce") ? "VCE Biology" : "Biology Trivia";
}

function getCharacterLabel(){
  const el = gameState.player?.element || "water";
  if(el === "electric") return { name: "Spark", emoji: "‚ö°" };
  if(el === "fire") return { name: "Flame", emoji: "üî•" };
  return { name: "Bubbles", emoji: "üíß" };
}

function getRank(score){
  if(score >= 7000) return { name: "Pond Legend", emoji: "üëë" };
  if(score >= 4500) return { name: "Element Master", emoji: "üî•" };
  if(score >= 2500) return { name: "Storm Survivor", emoji: "‚ö°" };
  if(score >= 1000) return { name: "Pond Explorer", emoji: "üå±" };
  return { name: "Tadpole Beginner", emoji: "üê£" };
}

async function shareScore(){
  const mode = getModeLabel();
  const ch = getCharacterLabel();
  const rank = getRank(gameState.points);

  const url = window.location.href.split('#')[0];
  const text = `I reached ${rank.name} ${rank.emoji} in Tadpole Trials 2!\nScore: ${gameState.points} | Quiz: ${gameState.overall.correct}/${gameState.overall.total}\nCharacter: ${ch.name} | Mode: ${mode}\n\nCan you beat me?\n${url}`;

  // Prefer native share on mobile (text + url only)
  if(navigator.share){
    try {
      await navigator.share({ title: "Tadpole Trials 2", text, url });
      return;
    } catch(e) {
      // user cancelled or share not available - fall back to clipboard
    }
  }

  // Clipboard fallback
  try { await navigator.clipboard.writeText(text); } catch(e) {}
  alert("Link copied! Paste it anywhere to challenge someone to beat your score.");
}
const questionText = document.getElementById('questionText');
    const optionsContainer = document.getElementById('optionsContainer');
    const scoreSummary = document.getElementById('scoreSummary');
    const finalText = document.getElementById('finalText');

    const collectedCount = document.getElementById('collectedCount');
    const pointsDisplayQuiz = document.getElementById('pointsDisplayQuiz');
    const levelIndicator = document.querySelector('.level-indicator');
    const deathOverlay = document.getElementById('deathOverlay');
    const introOverlay = document.getElementById('introOverlay');
    const introContinueBtn = document.getElementById('introContinueBtn');
    const mobileControls = document.getElementById('mobileControls');
    const ctx = gameCanvas.getContext('2d');
    
// Snow particle setup
const snowParticles = [];
const maxSnowParticles = 200;

function initSnow() {
  for (let i = 0; i < maxSnowParticles; i++) {
    snowParticles.push({
      x: Math.random() * gameCanvas.width,
      y: Math.random() * gameCanvas.height,
      size: Math.random() * 3 + 1,
      speed: Math.random() * 2 + 1,
      wind: (Math.random() - 0.5) * 0.5,
      opacity: Math.random() * 0.5 + 0.5
    });
  }
}

    // Mobile control elements
    const leftBtn = document.getElementById('leftBtn');
    const rightBtn = document.getElementById('rightBtn');
    const upBtn = document.getElementById('upBtn');
    const jumpBtn = document.getElementById('jumpBtn');
    const shootBtn = document.getElementById('shootBtn');

    // Start Screen Animation Code
    const startCanvas = document.getElementById('startCanvas');
    const startCtx = startCanvas.getContext('2d');

    // Set canvas size
    function resizeStartCanvas() {
      startCanvas.width = startCanvas.offsetWidth;
      startCanvas.height = startCanvas.offsetHeight;
    }
    resizeStartCanvas();
    window.addEventListener('resize', resizeStartCanvas);

    // Game state with mouse tracking
    const startScreenState = {
      mouse: { x: 0, y: 0, isActive: false },
      screen: 'start',
      enemyX: startCanvas.width/2,
      enemyDirection: 1
    };

    // Mouse/touch tracking
    startCanvas.addEventListener('mousemove', (e) => {
      const rect = startCanvas.getBoundingClientRect();
      startScreenState.mouse.x = e.clientX - rect.left;
      startScreenState.mouse.y = e.clientY - rect.top;
      startScreenState.mouse.isActive = true;
    });

    startCanvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      const rect = startCanvas.getBoundingClientRect();
      startScreenState.mouse.x = e.touches[0].clientX - rect.left;
      startScreenState.mouse.y = e.touches[0].clientY - rect.top;
      startScreenState.mouse.isActive = true;
    });

    startCanvas.addEventListener('mouseout', () => {
      startScreenState.mouse.isActive = false;
    });

    // Animation loop
    function animateStartScreen() {
      updateEnemyPosition();
      drawStartScreen();
      window._startScreenAnimFrame = requestAnimationFrame(animateStartScreen);
    }

    function updateEnemyPosition() {
      // Move enemy back and forth (slower)
      startScreenState.enemyX += startScreenState.enemyDirection * 1;
      
      // Reverse direction at edges
      if (startScreenState.enemyX > startCanvas.width - 100) {
        startScreenState.enemyDirection = -1;
      } else if (startScreenState.enemyX < 100) {
        startScreenState.enemyDirection = 1;
      }
    }

    // Main drawing function
    function drawStartScreen() {
      const width = startCanvas.width;
      const height = startCanvas.height;
      const now = Date.now();
      
      // Clear canvas
      startCtx.clearRect(0, 0, width, height);
      
      // Draw background gradient
      const gradient = startCtx.createLinearGradient(0, 0, 0, height);
      gradient.addColorStop(0, '#1a2a6c');
      gradient.addColorStop(1, '#0a1a3a');
      startCtx.fillStyle = gradient;
      startCtx.fillRect(0, 0, width, height);
      
      // Draw bubbles
      startCtx.fillStyle = 'rgba(255,255,255,0.1)';
      for (let i = 0; i < 30; i++) {
        const seed = i * 100;
        const x = (seed * 31) % width;
        const y = (height + seed - (now / 50) % (height + 200));
        const size = 3 + (seed % 10);
        startCtx.beginPath();
        startCtx.arc(x, y, size, 0, Math.PI * 2);
        startCtx.fill();
      }
      
      // Draw the single horizontal enemy
      drawEnemy(startScreenState.enemyX, height/2 + 100);
      
      // Draw hero tadpole (eyes will track enemy or mouse)
      drawHeroTadpole(width/2, height/2 - 50);
    }

    function drawHeroTadpole(x, y) {
  const size = 100;
  const now = Date.now();

  // === Body Gradient ===
  let bodyGradient;
  const element = gameState.player.element;

  if (element === "electric") {
    bodyGradient = startCtx.createRadialGradient(x - size / 4, y - size / 4, size / 8, x, y, size / 2);
    bodyGradient.addColorStop(0, '#ffdb4d'); // soft warm yellow
    bodyGradient.addColorStop(1, '#ff9900'); // vibrant orange-gold
  } else if (element === "fire") {
    bodyGradient = startCtx.createRadialGradient(x - size / 4, y - size / 4, size / 8, x, y, size / 2);
    bodyGradient.addColorStop(0, '#ff5500');
    bodyGradient.addColorStop(1, '#cc0000');
  } else {
    // Water is default
    bodyGradient = startCtx.createRadialGradient(x - size / 4, y - size / 4, size / 8, x, y, size / 2);
    bodyGradient.addColorStop(0, '#7fd8ff'); // aqua-mint
    bodyGradient.addColorStop(1, '#2aa8e6'); // teal
  }

  // Draw main body
  startCtx.fillStyle = bodyGradient;
  startCtx.beginPath();
  startCtx.arc(x, y, size / 2, 0, Math.PI * 2);
  startCtx.fill();

  // === Tail Animation ===
  const tailWiggle = Math.sin(now / 200) * 15;
  startCtx.beginPath();
  startCtx.moveTo(x + size / 2, y);
  startCtx.quadraticCurveTo(x + size + 20, y + tailWiggle, x + size / 1.5, y + size / 1.5 + tailWiggle / 2);
  startCtx.quadraticCurveTo(x + size / 2 + 10, y + size / 3, x + size / 2, y);
  startCtx.fill();

  // === Element-Specific Effects ===
  if (element === "fire") {
    // üî• Flame flickers
    for (let i = 0; i < 5; i++) {
      const flickerOffset = i * 150;
      const fx = x + Math.sin((now + flickerOffset) / 400) * 12;
      const fy = y - 40 - i * 8 + Math.sin((now + flickerOffset) / 600) * 5;
      const r = 3 + Math.sin((now + flickerOffset) / 300) * 2;
      const alpha = 0.2 + Math.sin((now + flickerOffset) / 500) * 0.2;

      startCtx.beginPath();
      startCtx.fillStyle = `rgba(255, ${100 + Math.sin((now + flickerOffset) / 250) * 60}, 0, ${Math.max(0, alpha)})`;
      startCtx.arc(fx, fy, Math.abs(r), 0, Math.PI * 2);
      startCtx.fill();
    }

    // üí® Smoke
    for (let i = 0; i < 2; i++) {
      const sx = x - 10 + Math.random() * 20;
      const sy = y + 30 + Math.random() * 10;
      const sr = 3 + Math.random() * 3;
      startCtx.beginPath();
      startCtx.fillStyle = `rgba(50, 50, 50, ${0.05 + Math.random() * 0.1})`;
      startCtx.arc(sx, sy, sr, 0, Math.PI * 2);
      startCtx.fill();
    }

    // üî• Flame spikes
    for (let i = 0; i < 4; i++) {
      const flameX = x - 20 + i * 13;
      const flameY = y - 50 + Math.sin(now / 200 + i) * 4;
      const flameHeight = 18 + Math.sin(now / 150 + i * 2) * 4;

      startCtx.beginPath();
      startCtx.moveTo(flameX, flameY + flameHeight);
      startCtx.quadraticCurveTo(flameX + 5, flameY, flameX + 10, flameY + flameHeight);
      startCtx.fillStyle = `rgba(255, ${80 + Math.sin(now / 250 + i) * 100}, 0, 0.8)`;
      startCtx.fill();
    }
  }

  if (element === "electric") {
    // ‚ö° Body Sparks
    startCtx.strokeStyle = '#ffff99';
    startCtx.lineWidth = 1.5;
    for (let i = 0; i < 3; i++) {
      let sx = x + (Math.random() - 0.5) * 20;
      let sy = y + (Math.random() - 0.5) * 20;
      startCtx.beginPath();
      startCtx.moveTo(x, y);
      for (let j = 0; j < 3; j++) {
        sx += (Math.random() - 0.5) * 6;
        sy += (Math.random() - 0.5) * 6;
        startCtx.lineTo(sx, sy);
      }
      startCtx.stroke();
    }

    // ‚ö° Spark Arcs Above Head
    for (let i = 0; i < 4; i++) {
      const sparkX = x - 20 + i * 13 + Math.random() * 4;
      const sparkY = y - 45 + Math.sin(now / 100 + i) * 5;
      const sparkLen = 8 + Math.random() * 4;

      startCtx.beginPath();
      startCtx.moveTo(sparkX, sparkY);
      startCtx.lineTo(sparkX + (Math.random() - 0.5) * 6, sparkY - sparkLen);
      startCtx.strokeStyle = 'rgba(255, 255, 150, 0.8)';
      startCtx.lineWidth = 1;
      startCtx.stroke();
    }

    // ‚ú® Glow Ring
    startCtx.beginPath();
    startCtx.arc(x, y, size / 2 + 5, 0, Math.PI * 2);
    startCtx.strokeStyle = 'rgba(255, 255, 100, 0.2)';
    startCtx.lineWidth = 3;
    startCtx.stroke();
  }

  if (element === "water") {
  const aqua = '#7fd8ff';

  // üåä Glow Ring
  startCtx.beginPath();
  startCtx.arc(x, y, size / 2 + 5, 0, Math.PI * 2);
  startCtx.strokeStyle = 'rgba(127, 216, 255, 0.25)'; // Converted aqua to RGBA
  startCtx.lineWidth = 4;
  startCtx.stroke();

  // üåä Ripple Effect
  for (let i = 0; i < 2; i++) {
    const rippleRadius = size / 2 + 6 + Math.sin(now / 250 + i) * 3;
    startCtx.beginPath();
    startCtx.arc(x, y, rippleRadius, 0, Math.PI * 2);
    startCtx.strokeStyle = 'rgba(127, 216, 255, 0.1)';
    startCtx.lineWidth = 2.5;
    startCtx.stroke();
  }

  // üíß Aqua-Themed Floating Bubbles
  for (let i = 0; i < 6; i++) {
    const offset = i * 120;
    const bubbleX = x + Math.sin((now + offset) / 250) * 12;
    const bubbleY = y - 40 - ((now + offset) / 15) % 60;
    const bubbleRadius = 3.5 + Math.sin((now + offset) / 300) * 1.5;

    startCtx.beginPath();
    startCtx.arc(bubbleX, bubbleY, bubbleRadius, 0, Math.PI * 2);
    startCtx.fillStyle = 'rgba(127, 216, 255, 0.5)'; // Tadpole Aqua
    startCtx.fill();

    // Subtle highlight
    startCtx.beginPath();
    startCtx.arc(bubbleX - 1, bubbleY - 1, bubbleRadius * 0.3, 0, Math.PI * 2);
    startCtx.fillStyle = 'rgba(255, 255, 255, 0.15)';
    startCtx.fill();
  }
}


      
      
      // Draw two cute, rounder, farther apart eyes
      const eyeWidth = size/10;
      const eyeHeight = size/10;
      const eyeY = y - size/8.5;
      const eyeSpacing = size/3.2; // even farther apart

      // Determine what to look at
      let lookX, lookY;
      if (startScreenState.mouse.isActive) {
        lookX = startScreenState.mouse.x;
        lookY = startScreenState.mouse.y;
      } else {
        // Look at enemy when not tracking mouse
        lookX = startScreenState.enemyX;
        lookY = startCanvas.height/2 + 100;
      }

      // Left eye (round)
      startCtx.fillStyle = 'white';
      startCtx.beginPath();
      startCtx.arc(x - eyeSpacing/2, eyeY, eyeWidth, 0, Math.PI * 2);
      startCtx.fill();

      // Right eye (round)
      startCtx.beginPath();
      startCtx.arc(x + eyeSpacing/2, eyeY, eyeWidth, 0, Math.PI * 2);
      startCtx.fill();

      // Eye pupils (bigger, more centered for cuteness)
      startCtx.fillStyle = 'black';

      // Left pupil
      let pupilX = x - eyeSpacing/2 + (lookX - x) / 80;
      let pupilY = eyeY + (lookY - y) / 80;
      startCtx.beginPath();
      startCtx.arc(pupilX, pupilY, eyeWidth/2.2, 0, Math.PI * 2);
      startCtx.fill();

      // Right pupil
      pupilX = x + eyeSpacing/2 + (lookX - x) / 80;
      startCtx.beginPath();
      startCtx.arc(pupilX, pupilY, eyeWidth/2.2, 0, Math.PI * 2);
      startCtx.fill();

      // Add a little white shine for extra cuteness
      startCtx.fillStyle = 'white';
      startCtx.globalAlpha = 0.7;
      startCtx.beginPath();
      startCtx.arc(x - eyeSpacing/2 - eyeWidth/4, eyeY - eyeWidth/4, eyeWidth/5, 0, Math.PI * 2);
      startCtx.fill();
      startCtx.beginPath();
      startCtx.arc(x + eyeSpacing/2 - eyeWidth/4, eyeY - eyeWidth/4, eyeWidth/5, 0, Math.PI * 2);
      startCtx.fill();
      startCtx.globalAlpha = 1.0;
      
      // Cute mouth (smaller, higher, more smiley)
      const mouthHappy = startScreenState.mouse.isActive || 
        (Math.abs(startScreenState.enemyX - x) < 150 && Math.abs((startCanvas.height/2 + 100) - y) < 150);

      startCtx.strokeStyle = '#333';
      startCtx.lineWidth = 2.2;
      startCtx.beginPath();
      if (mouthHappy) {
        startCtx.arc(x, y + size/7.5, size/15, 0, Math.PI, false); // Big smile
      } else {
        startCtx.arc(x, y + size/7.5, size/15, Math.PI * 0.1, Math.PI * 0.9); // Neutral
      }
      startCtx.stroke();
    }

    function drawEnemy(x, y) {
      const width = 60;
      const height = 40;
      
      // Draw body
      startCtx.fillStyle = '#FF0000';
      startCtx.fillRect(x - width/2, y - height/2, width, height);
      
      // Draw eyes (facing direction of movement)
      startCtx.fillStyle = 'white';
      startCtx.beginPath();
      
      const eyeOffset = startScreenState.enemyDirection > 0 ? 10 : 5;
      
      startCtx.arc(x - width/2 + eyeOffset, y - height/2 + 15, 5, 0, Math.PI * 2);
      startCtx.arc(x + width/2 - eyeOffset, y - height/2 + 15, 5, 0, Math.PI * 2);
      startCtx.fill();
      
      // Draw pupils
      startCtx.fillStyle = 'black';
      startCtx.beginPath();
      startCtx.arc(x - width/2 + eyeOffset, y - height/2 + 15, 3, 0, Math.PI * 2);
      startCtx.arc(x + width/2 - eyeOffset, y - height/2 + 15, 3, 0, Math.PI * 2);
      startCtx.fill();
    }

    function showScreen(screen) {
      // Hide all screens
      startScreen.style.display = 'none';
      gameCanvas.style.display = 'none';
      quizScreen.style.display = 'none';
      scoreScreen.style.display = 'none';
      finalScreen.style.display = 'none';
      startCanvas.style.display = 'none';
      document.querySelector('.controls-info')?.style.setProperty('display', 'none');

      // Show requested screen
      screen.style.display = 'flex';
      
      // Toggle game-active class
      const gameContainer = document.querySelector('.game-container');
      gameContainer.classList.toggle('game-active', screen === gameCanvas);

      // Special handling for start screen
      if (screen === startScreen) {
        startCanvas.style.display = 'block';
        document.querySelector('.controls-info')?.style.setProperty('display', 'block');
        if (!window._startScreenAnimFrame) {
          animateStartScreen();
        }
      } else {
        if (window._startScreenAnimFrame) {
          cancelAnimationFrame(window._startScreenAnimFrame);
          window._startScreenAnimFrame = null;
        }
      }
    }

    // Initialize game
    
    // =========================
    // Sound FX (no external assets)
    // Uses Web Audio oscillator tones (safe + license-free).
    // =========================
    const SFX = {
      enabled: true,
      ctx: null,
      master: null
    };

    function initAudio() {
      if (SFX.ctx) return;
      const AC = window.AudioContext || window.webkitAudioContext;
      if (!AC) return; // very old browsers
      SFX.ctx = new AC();
      SFX.master = SFX.ctx.createGain();
      SFX.master.gain.value = 0.65;
      SFX.master.connect(SFX.ctx.destination);
    }

    async function unlockAudio() {
      initAudio();
      if (!SFX.ctx) return;
      if (SFX.ctx.state === 'suspended') {
        try { await SFX.ctx.resume(); } catch (e) {}
      }
    }

    function setSfxEnabled(on) {
      SFX.enabled = !!on;
      if (soundToggle) soundToggle.textContent = SFX.enabled ? 'üîä' : 'üîá';
      // persist preference
      try { localStorage.setItem('tt2_sfx', SFX.enabled ? '1' : '0'); } catch(e) {}
    }

    function envGain(gainNode, now, attack, decay, peak) {
      gainNode.gain.cancelScheduledValues(now);
      gainNode.gain.setValueAtTime(0.0001, now);
      gainNode.gain.linearRampToValueAtTime(Math.max(0.0001, peak), now + attack);
      gainNode.gain.exponentialRampToValueAtTime(0.0001, now + attack + decay);
    }

    function playTone({ freq = 440, duration = 0.12, type = 'sine', peak = 0.22, attack = 0.005, decay = 0.12, detune = 0 }) {
      if (!SFX.enabled) return;
      initAudio();
      if (!SFX.ctx) return;

      const now = SFX.ctx.currentTime;
      const osc = SFX.ctx.createOscillator();
      const gain = SFX.ctx.createGain();

      osc.type = type;
      osc.frequency.setValueAtTime(freq, now);
      if (detune) osc.detune.setValueAtTime(detune, now);

      envGain(gain, now, attack, decay, peak);

      osc.connect(gain);
      gain.connect(SFX.master);

      osc.start(now);
      osc.stop(now + Math.max(0.02, duration));
    }

    function playNoise({ duration = 0.10, peak = 0.14, attack = 0.003, decay = 0.10, bandpass = 900 }) {
      if (!SFX.enabled) return;
      initAudio();
      if (!SFX.ctx) return;

      const now = SFX.ctx.currentTime;

      const bufferSize = Math.floor(SFX.ctx.sampleRate * duration);
      const buffer = SFX.ctx.createBuffer(1, bufferSize, SFX.ctx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1);

      const src = SFX.ctx.createBufferSource();
      src.buffer = buffer;

      const filter = SFX.ctx.createBiquadFilter();
      filter.type = 'bandpass';
      filter.frequency.setValueAtTime(bandpass, now);

      const gain = SFX.ctx.createGain();
      envGain(gain, now, attack, decay, peak);

      src.connect(filter);
      filter.connect(gain);
      gain.connect(SFX.master);

      src.start(now);
      src.stop(now + duration + 0.02);
    }

    function playSfx(name) {
      // Keep these punchy + short so mobile doesn‚Äôt feel noisy.
      switch (name) {
        case 'jump':     playTone({ freq: 520, type: 'triangle', peak: 0.14, decay: 0.10 }); break;
        case 'shoot':    playTone({ freq: 740, type: 'square',  peak: 0.12, decay: 0.07 }); break;
        case 'collect':  playTone({ freq: 880, type: 'sine',    peak: 0.16, decay: 0.10 }); break;
        case 'hit':      playNoise({ bandpass: 1400, peak: 0.10, decay: 0.08 }); playTone({ freq: 220, type: 'square', peak: 0.06, decay: 0.06 }); break;
        case 'die':      playTone({ freq: 140, type: 'sawtooth', peak: 0.16, decay: 0.18 }); break;
        case 'level':    playTone({ freq: 660, type: 'sine', peak: 0.12, decay: 0.10 }); playTone({ freq: 990, type: 'sine', peak: 0.10, decay: 0.14 }); break;
        case 'correct':  playTone({ freq: 880, type: 'sine', peak: 0.12, decay: 0.08 }); playTone({ freq: 1175, type: 'sine', peak: 0.10, decay: 0.10 }); break;
        case 'wrong':    playTone({ freq: 220, type: 'square', peak: 0.10, decay: 0.18 }); break;
        case 'win':      playTone({ freq: 660, type: 'triangle', peak: 0.10, decay: 0.10 }); playTone({ freq: 880, type: 'triangle', peak: 0.10, decay: 0.12 }); playTone({ freq: 1100, type: 'triangle', peak: 0.10, decay: 0.14 }); break;
        default: break;
      }
    }


    function init() {

      // --- SFX setup ---
      try {
        const saved = localStorage.getItem('tt2_sfx');
        if (saved === '0') setSfxEnabled(false);
        else setSfxEnabled(true);
      } catch (e) { setSfxEnabled(true); }

      if (soundToggle) {
        soundToggle.addEventListener('click', async () => {
          await unlockAudio();
          setSfxEnabled(!SFX.enabled);
        });
      }

      // Browsers require user gesture before audio will play
      document.addEventListener('pointerdown', unlockAudio, { once: true });
      document.addEventListener('keydown', unlockAudio, { once: true });
      // Ensure game canvas is always 800x400 for crisp scaling
      function resizeGameCanvas() {
        gameCanvas.width = 800;
        gameCanvas.height = 400;
      }
      resizeGameCanvas();
       // üîπ Initialize snow particles once at startup
  initSnow();
      
      // Start the start screen animation
      animateStartScreen();

      // Set up character selection
      const charOptions = document.querySelectorAll('.char-option');
      charOptions.forEach(option => {
        option.addEventListener('click', () => {
          // Remove selected class from all options
          charOptions.forEach(opt => opt.classList.remove('selected'));
          // Add selected class to clicked option
          option.classList.add('selected');
          // Set player element
          gameState.player.element = option.dataset.char;
        });
      });
      
      // Set up topic selection
      const topicButtons = document.querySelectorAll('.topic-btn');
      topicButtons.forEach(btn => {
        btn.addEventListener('click', () => {
          topicButtons.forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          gameState.selectedTopic = btn.dataset.topic;
        });
      });

      startBtn.addEventListener('click', startGame);
      retryBtn.addEventListener('click', retryLevel);
      nextBtn.addEventListener('click', nextLevel);
      restartBtn.addEventListener('click', restartGame);
      
      if(shareBtn){ shareBtn.addEventListener('click', shareScore); }
      document.addEventListener('keydown', handleKeyDown);
      document.addEventListener('keyup', handleKeyUp);
      
      if (isMobile) {
        const buttonActions = {
          leftBtn: 'left',
          rightBtn: 'right',
          upBtn: 'up',
          jumpBtn: 'up',
          shootBtn: 'shoot'
        };

        Object.entries(buttonActions).forEach(([id, key]) => {
          const btn = document.getElementById(id);

          // Touch control logic
          btn.addEventListener('touchstart', () => gameState.keys[key] = true);
          btn.addEventListener('touchend', () => gameState.keys[key] = false);

          // Prevent unwanted mobile behavior
          btn.addEventListener('contextmenu', e => e.preventDefault());
          btn.addEventListener('selectstart', e => e.preventDefault());
          btn.addEventListener('touchstart', e => e.preventDefault(), { passive: false });

          // Optional: removes grey highlight on tap
          btn.style.webkitTapHighlightColor = 'transparent';
        });
      }
      
      // Initial screen setup
      showScreen(startScreen);
      deathOverlay.style.display = 'none';
    }

    // Start the game
    function startGame() {
      // Show the intro once per "Play Again" cycle
      resetGameState();

      // Stop start screen animation if it's running
      if (window._startScreenAnimFrame) cancelAnimationFrame(window._startScreenAnimFrame);

      // Show game canvas (but pause gameplay until intro dismissed)
      showScreen(gameCanvas);
      setupLevel(1);
      gameState.gameActive = false;

      // Show intro overlay
      introOverlay.style.display = 'flex';

      const dismissIntro = () => {
        introOverlay.style.display = 'none';
        document.removeEventListener('keydown', onAnyKey);
        document.removeEventListener('pointerdown', onPointerDown);

        gameState.gameActive = true;
        requestAnimationFrame(gameLoop);
      };

      const onAnyKey = (e) => {
        // Ignore modifier keys
        if (e.key === 'Shift' || e.key === 'Alt' || e.key === 'Control' || e.key === 'Meta') return;
        dismissIntro();
      };

      const onPointerDown = () => dismissIntro();

      // Button + quick dismiss options
      introContinueBtn.onclick = dismissIntro;
      document.addEventListener('keydown', onAnyKey);
      document.addEventListener('pointerdown', onPointerDown, { once: true });
    }
    let elementStats = {
        water:    { speed: 3.4, jump: -12.5, friction: 0.6, gravity: 0.48 },
        fire:     { speed: 3.6, jump: -13,   friction: 0.55, gravity: 0.52 },
        electric: { speed: 4.0, jump: -11,   friction: 0.65, gravity: 0.5 }
};

const element = gameState.player.element || 'water';
const stats = elementStats[element];


    // Set up a level
    function normalizeTopic(t){
      return t;
    }

    function applyDifficultyTuning(level) {
      // Slightly increase difficulty by making platforms a bit shorter (increasing gaps),
      // while keeping jumps achievable. This scales gently with level number.
      const shrink = Math.min(0.10, Math.max(0, (level - 1) * 0.012)); // up to 10%
      if (level >= 2 && gameState.platforms) {
        for (const p of gameState.platforms) {
          if (p.width >= 130) {
            p.width = Math.max(95, Math.round(p.width * (1 - shrink)));
          }
        }
      }

      // Add a small number of extra enemies in higher levels, placed safely on platforms.
      const extra = (level >= 9) ? 2 : (level >= 6 ? 1 : 0);
      if (extra > 0 && gameState.platforms && gameState.enemies) {
        const platformsByX = [...gameState.platforms].sort((a,b)=>a.x-b.x);
        const pickIndices = (level >= 9) ? [Math.floor(platformsByX.length*0.55), Math.floor(platformsByX.length*0.8)]
                                         : [Math.floor(platformsByX.length*0.7)];
        for (let k = 0; k < extra; k++) {
          const idx = Math.min(platformsByX.length - 1, Math.max(0, pickIndices[k] || (platformsByX.length-2)));
          let plat = platformsByX[idx];
          // Avoid spawning extra enemies on vertically moving platforms (looks weird)
          let guard = 0;
          while(plat && plat.vy && guard < platformsByX.length){
            idx = Math.min(platformsByX.length - 1, idx + 1);
            plat = platformsByX[idx];
            guard++;
          }
          const env = plat.type || 'ground';

          // Choose a contrasting enemy type for visibility
          let type = 'sentinel';
          if (env === 'magma') type = 'ice';
          else if (env === 'ice') type = 'nightmare';
          else if (env === 'dark') type = 'ice';
          else type = 'nightmare';

          // Place enemy with patrol bounds inside platform (avoid edges)
          const ex = plat.x + Math.min(40, Math.max(18, plat.width * 0.18));
          const ey = plat.y - 35;
          const minX = plat.x + 10;
          const maxX = plat.x + plat.width - 45;

          if (maxX > minX + 25) {
            gameState.enemies.push({
              x: ex,
              y: ey,
              width: 35,
              height: 35,
              velX: 1.55 + (level * 0.03),
              minX,
              maxX,
              type,
              alive: true
            });
          }
        }
      }

      // Make existing enemy speeds very slightly higher for a general difficulty lift
      if (gameState.enemies) {
        for (const e of gameState.enemies) {
          if (typeof e.velX === 'number') {
            e.velX *= 1.06;
          }
          if (typeof e.velY === 'number') {
            e.velY *= 1.04;
          }
          if (typeof e.attackTimer === 'number') {
            e.attackTimer = Math.max(24, Math.round(e.attackTimer * 0.94));
          }
        }
      }
    }

    function setupLevel(level) {
      gameState.currentLevel = level;
      gameState.player = {
        x: 100,
        y: 300,
        width: 30,
        height: 30,
        velX: 0,
        velY: 0,
        speed: isMobile ? 5.0 : 3.5,
        jumpPower: stats.jump,
        gravity: stats.gravity,
        friction: stats.friction,
        jumping: false,
        direction: 1,
        grounded: false,
        lives: 3,
        element: gameState.player.element // Preserve selected element
      };
      gameState.collectedBrains = [];
      gameState.platforms = [];
      gameState.brains = [];
      gameState.enemies = [];
      gameState.playerProjectiles = [];
      gameState.enemyProjectiles = [];
      gameState.quizQuestions = [];
      gameState.particles = [];
      gameState.splashes = [];
      gameState.zaps = [];
      // Only reset usedQuestions if starting a new game (level 1)
      if (level === 1) {
        gameState.usedQuestions = [];
      }
      gameState.levelScore = { correct: 0, total: 0 };
      startLevelScoring();
      gameState.cameraX = 0;
      gameState.isDead = false;
      gameState.shootCooldown = 0;
      
      levelIndicator.textContent = `Level ${level}: ${gameState.levels[level-1].name}`;
      
      // Create platforms
      gameState.platforms.push({x: 0, y: 350, width: gameState.levelWidth, height: 20, type: 'ice'}); 
      
      // Level-specific configurations
      // NOTE: Fixed, hand-authored levels (no procedural generation) for consistent play.
      // Designed to scale difficulty gradually and avoid impossible jumps.
      if (level === 1) {
        // Level 1: Lost: Wild Storm (gentle intro)
        gameState.levelWidth = 2600;

        gameState.platforms = [
          {x: 40,  y: 330, width: 260, height: 25, type: 'ground'},
          {x: 360, y: 300, width: 180, height: 25, type: 'ground'},
          {x: 600, y: 330, width: 180, height: 25, type: 'ground'},
          {x: 840, y: 285, width: 160, height: 25, type: 'ground'},
          {x: 1060,y: 330, width: 220, height: 25, type: 'ground'},
          {x: 1340,y: 300, width: 170, height: 25, type: 'ground'},
          {x: 1570,y: 330, width: 220, height: 25, type: 'ground'},
          {x: 1860,y: 285, width: 160, height: 25, type: 'ground'},
          {x: 2080,y: 330, width: 220, height: 25, type: 'ground'},
          {x: 2350,y: 310, width: 200, height: 25, type: 'ground'}
        ];

        gameState.brains = [
          {x: 420,  y: 260, collected: false},
          {x: 660,  y: 290, collected: false},
          {x: 1120, y: 290, collected: false},
          {x: 1640, y: 290, collected: false},
          {x: 2380, y: 270, collected: false}
        ];

        gameState.enemies = [
          // One slow patroller on a wide platform (teaches avoidance / shooting)
          {x: 1100, y: 295, width: 35, height: 35, velX: 0.7, minX: 1060, maxX: 1240, type: 'sentinel', alive: true}
        ];

      } else if (level === 2) {
        // Level 2: Snow Forest (slightly tighter jumps, more movement)
        gameState.levelWidth = 3000;

        gameState.platforms = [
          {x: 40,  y: 330, width: 240, height: 25, type: 'ice'},
          {x: 320, y: 285, width: 150, height: 25, type: 'ice'},
          {x: 520, y: 240, width: 140, height: 25, type: 'ice'},
          {x: 710, y: 285, width: 150, height: 25, type: 'ice'},
          {x: 910, y: 330, width: 220, height: 25, type: 'ice'},
          {x: 1180,y: 285, width: 150, height: 25, type: 'ice'},
          {x: 1380,y: 240, width: 140, height: 25, type: 'ice'},
          {x: 1570,y: 285, width: 150, height: 25, type: 'ice'},
          {x: 1770,y: 330, width: 240, height: 25, type: 'ice'},
          {x: 2050,y: 285, width: 150, height: 25, type: 'ice'},
          {x: 2250,y: 330, width: 220, height: 25, type: 'ice'},
          {x: 2520,y: 300, width: 220, height: 25, type: 'ice'},
          {x: 2770,y: 330, width: 200, height: 25, type: 'ice'}
        ];

        gameState.brains = [
          {x: 350,  y: 245, collected: false},
          {x: 560,  y: 200, collected: false},
          {x: 980,  y: 290, collected: false},
          {x: 1410, y: 200, collected: false},
          {x: 2550, y: 260, collected: false}
        ];

        gameState.enemies = [
          {x: 980,  y: 295, width: 35, height: 35, velX: 0.9, minX: 920,  maxX: 1120, type: 'ice', alive: true},
          {x: 1840, y: 295, width: 35, height: 35, velX: 1.0, minX: 1780, maxX: 1980, type: 'ice', alive: true}
        ];

      } else if (level === 3) {
        // Level 3: Caves (introduce verticality + first ranged threat)
        gameState.levelWidth = 3200;

        gameState.platforms = [
          {x: 40,  y: 330, width: 240, height: 25, type: 'dark'},
          {x: 320, y: 300, width: 160, height: 25, type: 'dark'},
          {x: 520, y: 255, width: 140, height: 25, type: 'dark'},
          {x: 700, y: 210, width: 120, height: 25, type: 'dark'},
          {x: 860, y: 255, width: 140, height: 25, type: 'dark'},
          {x: 1040,y: 300, width: 160, height: 25, type: 'dark'},
          {x: 1240,y: 330, width: 240, height: 25, type: 'dark'},
          {x: 1520,y: 300, width: 160, height: 25, type: 'dark'},
          {x: 1720,y: 255, width: 140, height: 25, type: 'dark'},
          {x: 1900,y: 210, width: 120, height: 25, type: 'dark'},
          {x: 2060,y: 255, width: 140, height: 25, type: 'dark'},
          {x: 2240,y: 300, width: 160, height: 25, type: 'dark'},
          {x: 2440,y: 330, width: 260, height: 25, type: 'dark'},
          {x: 2740,y: 300, width: 180, height: 25, type: 'dark'},
          {x: 2960,y: 330, width: 220, height: 25, type: 'dark'}
        ];

        gameState.brains = [
          {x: 350,  y: 260, collected: false},
          {x: 740,  y: 170, collected: false},
          {x: 1280, y: 290, collected: false},
          {x: 1940, y: 170, collected: false},
          {x: 2760, y: 260, collected: false}
        ];

        gameState.enemies = [
          {x: 560,  y: 285, width: 35, height: 35, velX: 1.0, minX: 520, maxX: 660, type: 'nightmare', alive: true},
          // Ranged enemy sits on a mid platform ‚Äì avoidable, teaches timing/shooting
          {x: 1560, y: 270, width: 30, height: 30, velX: 0, attackTimer: 50, attackRange: 320, type: 'ranged', alive: true},
          {x: 2480, y: 295, width: 35, height: 35, velX: 1.1, minX: 2440, maxX: 2680, type: 'nightmare', alive: true}
        ];

      } else if (level === 4) {
        // Level 4: Haunted Swamp (more enemies, mixed platform heights)
        gameState.levelWidth = 3600;

        gameState.platforms = [
          {x: 40,  y: 330, width: 240, height: 25, type: 'dark'},
          {x: 320, y: 285, width: 150, height: 25, type: 'dark'},
          {x: 520, y: 240, width: 130, height: 25, type: 'dark'},
          {x: 690, y: 285, width: 150, height: 25, type: 'dark'},
          {x: 890, y: 330, width: 220, height: 25, type: 'dark'},
          {x: 1160,y: 285, width: 150, height: 25, type: 'dark'},
          {x: 1360,y: 240, width: 130, height: 25, type: 'dark'},
          {x: 1530,y: 210, width: 120, height: 25, type: 'dark'},
          {x: 1680,y: 240, width: 130, height: 25, type: 'dark'},
          {x: 1850,y: 285, width: 150, height: 25, type: 'dark'},
          {x: 2050,y: 330, width: 240, height: 25, type: 'dark'},
          {x: 2340,y: 285, width: 150, height: 25, type: 'dark'},
          {x: 2540,y: 240, width: 130, height: 25, type: 'dark'},
          {x: 2710,y: 285, width: 150, height: 25, type: 'dark'},
          {x: 2910,y: 330, width: 260, height: 25, type: 'dark'},
          {x: 3220,y: 300, width: 260, height: 25, type: 'dark'}
        ];

        gameState.brains = [
          {x: 350,  y: 245, collected: false},
          {x: 560,  y: 200, collected: false},
          {x: 930,  y: 290, collected: false},
          {x: 1560, y: 170, collected: false},
          {x: 3250, y: 260, collected: false}
        ];

        gameState.enemies = [
          {x: 910,  y: 295, width: 35, height: 35, velX: 1.1, minX: 890,  maxX: 1110, type: 'sentinel', alive: true},
          {x: 1700, y: 220, width: 30, height: 30, velY: 1.2, minY: 190, maxY: 290, type: 'vertical', alive: true},
          {x: 2070, y: 295, width: 35, height: 35, velX: 1.2, minX: 2050, maxX: 2280, type: 'nightmare', alive: true},
          {x: 2940, y: 295, width: 35, height: 35, velX: 1.2, minX: 2910, maxX: 3170, type: 'sentinel', alive: true}
        ];

      } else if (level === 5) {
        // Level 5: Rainy Forest (longer run + more patrol coverage)
        gameState.levelWidth = 3800;

        gameState.platforms = [
          {x: 40,  y: 330, width: 260, height: 25, type: 'green'},
          {x: 340, y: 300, width: 170, height: 25, type: 'green'},
          {x: 560, y: 260, width: 150, height: 25, type: 'green'},
          {x: 750, y: 300, width: 170, height: 25, type: 'green'},
          {x: 970, y: 330, width: 260, height: 25, type: 'green'},
          {x: 1270,y: 285, width: 150, height: 25, type: 'dark'},
          {x: 1470,y: 240, width: 130, height: 25, type: 'dark'},
          {x: 1640,y: 285, width: 150, height: 25, type: 'green'},
          {x: 1840,y: 330, width: 260, height: 25, type: 'green'},
          {x: 2140,y: 300, width: 180, height: 25, type: 'green'},
          {x: 2230, y: 235, width: 120, height: 25, type: 'green', vx: 1.6, minX: 2140, maxX: 2400},
          {x: 2370,y: 260, width: 150, height: 25, type: 'green'},
          {x: 2560,y: 300, width: 180, height: 25, type: 'green'},
          {x: 2790,y: 330, width: 280, height: 25, type: 'green'},
          {x: 3120,y: 300, width: 200, height: 25, type: 'dark'},
          {x: 3380,y: 330, width: 320, height: 25, type: 'green'}
        ];

        gameState.brains = [
          {x: 380,  y: 260, collected: false},
          {x: 600,  y: 220, collected: false},
          {x: 1320, y: 245, collected: false},
          {x: 2190, y: 260, collected: false},
          {x: 3400, y: 290, collected: false}
        ];

        gameState.enemies = [
          {x: 590,  y: 245, width: 35, height: 35, velX: 1.2, minX: 560,  maxX: 710,  type: 'sentinel', alive: true},
          {x: 1010, y: 295, width: 35, height: 35, velX: 1.3, minX: 970,  maxX: 1230, type: 'sentinel', alive: true},
          {x: 1880, y: 295, width: 35, height: 35, velX: 1.3, minX: 1840, maxX: 2100, type: 'nightmare', alive: true},
          {x: 2810, y: 295, width: 35, height: 35, velX: 1.35,minX: 2790, maxX: 3070, type: 'sentinel', alive: true},
          {x: 3150, y: 270, width: 30, height: 30, velX: 0, attackTimer: 45, attackRange: 360, type: 'ranged', alive: true}
        ];

      } else if (level === 6) {
        // Level 6: Lake (ice platforms + tighter landing zones)
        gameState.levelWidth = 3200;

        gameState.platforms = [
          {x: 40,  y: 330, width: 230, height: 25, type: 'ice'},
          {x: 330, y: 285, width: 150, height: 25, type: 'ice'},
          {x: 545, y: 240, width: 135, height: 25, type: 'ice'},
          {x: 735, y: 285, width: 145, height: 25, type: 'ice'},
          {x: 955, y: 330, width: 220, height: 25, type: 'ice'},
          {x: 1245,y: 290, width: 150, height: 25, type: 'ice'},
          {x: 1465,y: 240, width: 130, height: 25, type: 'ice'},
          {x: 1665,y: 285, width: 145, height: 25, type: 'ice'},
          {x: 1895,y: 330, width: 240, height: 25, type: 'ice'},
          {x: 2195,y: 290, width: 150, height: 25, type: 'ice'},
          {x: 2415,y: 330, width: 210, height: 25, type: 'ice'},
          {x: 2685,y: 300, width: 210, height: 25, type: 'ice'},
          {x: 2965,y: 330, width: 190, height: 25, type: 'ice'}
        ];

        gameState.brains = [
          {x: 360,  y: 245, collected: false},
          {x: 575,  y: 200, collected: false},
          {x: 1010, y: 290, collected: false},
          {x: 1495, y: 200, collected: false},
          {x: 2715, y: 260, collected: false}
        ];

        gameState.enemies = [
          {x: 1010, y: 295, width: 35, height: 35, velX: 1.1, minX: 955,  maxX: 1175, type: 'ice', alive: true},
          {x: 1935, y: 295, width: 35, height: 35, velX: 1.15,minX: 1895, maxX: 2135, type: 'ice', alive: true},
          {x: 2445, y: 295, width: 35, height: 35, velX: 1.2, minX: 2415, maxX: 2625, type: 'ice', alive: true}
        ];

      } else if (level === 7) {
        // Level 7: City (longer + denser enemy coverage, but fair platforms)
        gameState.levelWidth = 3300;

        gameState.platforms = [
          {x: 40,  y: 330, width: 240, height: 25, type: 'dark'},
          {x: 330, y: 300, width: 160, height: 25, type: 'dark'},
          {x: 545, y: 260, width: 130, height: 25, type: 'dark'},
          {x: 735, y: 300, width: 150, height: 25, type: 'dark'},
          {x: 955, y: 330, width: 230, height: 25, type: 'dark'},
          {x: 1245,y: 285, width: 150, height: 25, type: 'dark'},
          {x: 1465,y: 240, width: 130, height: 25, type: 'dark'},
          {x: 1560, y: 210, width: 120, height: 25, type: 'dark', vy: 1.2, minY: 180, maxY: 300},
          {x: 1665,y: 285, width: 145, height: 25, type: 'dark'},
          {x: 1895,y: 330, width: 250, height: 25, type: 'dark'},
          {x: 2210,y: 300, width: 170, height: 25, type: 'dark'},
          {x: 2445,y: 260, width: 140, height: 25, type: 'dark'},
          {x: 2645,y: 300, width: 170, height: 25, type: 'dark'},
          {x: 2895,y: 330, width: 270, height: 25, type: 'dark'}
        ];

        gameState.brains = [
          {x: 365,  y: 260, collected: false},
          {x: 575,  y: 220, collected: false},
          {x: 1280, y: 245, collected: false},
          {x: 2260, y: 260, collected: false},
          {x: 2925, y: 290, collected: false}
        ];

        gameState.enemies = [
          {x: 565,  y: 245, width: 35, height: 35, velX: 1.25, minX: 545,  maxX: 675,  type: 'sentinel', alive: true},
          {x: 995,  y: 295, width: 35, height: 35, velX: 1.35, minX: 955,  maxX: 1185, type: 'sentinel', alive: true},
          {x: 1925, y: 295, width: 35, height: 35, velX: 1.35, minX: 1895, maxX: 2145, type: 'nightmare', alive: true},
          {x: 2685, y: 270, width: 30, height: 30, velX: 0, attackTimer: 42, attackRange: 380, type: 'ranged', alive: true},
          {x: 2480, y: 220, width: 30, height: 30, velY: 1.5, minY: 190, maxY: 290, type: 'vertical', alive: true}
        ];

      } else if (level === 8) {
        // Level 8: City Ruins (broken climbs + more mixed threats)
        gameState.levelWidth = 3400;

        gameState.platforms = [
          {x: 40,  y: 330, width: 240, height: 25, type: 'dark'},
          {x: 340, y: 300, width: 160, height: 25, type: 'dark'},
          {x: 560, y: 260, width: 135, height: 25, type: 'dark'},
          {x: 760, y: 220, width: 120, height: 25, type: 'dark'},
          {x: 940, y: 260, width: 135, height: 25, type: 'dark'},
          {x: 1160,y: 300, width: 160, height: 25, type: 'dark'},
          {x: 1400,y: 330, width: 250, height: 25, type: 'dark'},
          {x: 1710,y: 300, width: 160, height: 25, type: 'dark'},
          {x: 1930,y: 260, width: 135, height: 25, type: 'dark'},
          {x: 2130,y: 220, width: 120, height: 25, type: 'dark'},
          {x: 2310,y: 260, width: 135, height: 25, type: 'dark'},
          {x: 2530,y: 300, width: 160, height: 25, type: 'dark'},
          {x: 2770,y: 330, width: 260, height: 25, type: 'dark'},
          {x: 3090,y: 300, width: 190, height: 25, type: 'dark'}
        ];

        gameState.brains = [
          {x: 380,  y: 260, collected: false},
          {x: 790,  y: 180, collected: false},
          {x: 1450, y: 290, collected: false},
          {x: 2155, y: 180, collected: false},
          {x: 3120, y: 260, collected: false}
        ];

        gameState.enemies = [
          {x: 585,  y: 245, width: 35, height: 35, velX: 1.35, minX: 560,  maxX: 695,  type: 'nightmare', alive: true},
          {x: 1735, y: 270, width: 30, height: 30, velX: 0, attackTimer: 40, attackRange: 400, type: 'ranged', alive: true},
          {x: 2795, y: 295, width: 35, height: 35, velX: 1.45, minX: 2770, maxX: 3030, type: 'sentinel', alive: true},
          {x: 2315, y: 220, width: 30, height: 30, velY: 1.25, minY: 190, maxY: 285, type: 'vertical', alive: true},
          {x: 1165, y: 265, width: 35, height: 35, velX: 1.45, minX: 1160, maxX: 1320, type: 'ice', alive: true}
        ];

      } else if (level === 9) {
        // Level 9: Alien World (magma platforms + tougher enemy mixes)
        gameState.levelWidth = 3400;

        gameState.platforms = [
          {x: 40,  y: 330, width: 230, height: 25, type: 'magma'},
          {x: 330, y: 295, width: 150, height: 25, type: 'magma'},
          {x: 545, y: 255, width: 130, height: 25, type: 'magma'},
          {x: 735, y: 215, width: 120, height: 25, type: 'magma'},
          {x: 915, y: 255, width: 130, height: 25, type: 'magma'},
          {x: 1130,y: 295, width: 150, height: 25, type: 'magma'},
          {x: 1375,y: 330, width: 240, height: 25, type: 'magma'},
          {x: 1685,y: 295, width: 150, height: 25, type: 'magma'},
          {x: 1900,y: 255, width: 130, height: 25, type: 'magma'},
          {x: 2090,y: 215, width: 120, height: 25, type: 'magma'},
          {x: 2270,y: 255, width: 130, height: 25, type: 'magma'},
          {x: 2485,y: 295, width: 150, height: 25, type: 'magma'},
          {x: 2730,y: 330, width: 250, height: 25, type: 'magma'},
          {x: 3050,y: 300, width: 200, height: 25, type: 'magma'}
        ];

        gameState.brains = [
          {x: 360,  y: 255, collected: false},
          {x: 750,  y: 175, collected: false},
          {x: 1425, y: 290, collected: false},
          {x: 2110, y: 175, collected: false},
          {x: 3080, y: 260, collected: false}
        ];

        gameState.enemies = [
          {x: 350,  y: 280, width: 35, height: 35, velX: 1.4, minX: 330,  maxX: 480,  type: 'magma', alive: true},
          {x: 1145, y: 275, width: 35, height: 35, velX: 1.45, minX: 1130, maxX: 1280, type: 'magma', alive: true},
          {x: 1710, y: 270, width: 30, height: 30, velX: 0, attackTimer: 38, attackRange: 420, type: 'ranged', alive: true},
          {x: 2745, y: 295, width: 35, height: 35, velX: 1.55, minX: 2730, maxX: 2980, type: 'magma', alive: true},
          {x: 1905, y: 220, width: 30, height: 30, velY: 1.35, minY: 205, maxY: 285, type: 'vertical', alive: true}
        ];

      } else if (level === 10) {
        // Level 10: Pond: Coming Home (final ‚Äì but still fair)
        gameState.levelWidth = 3400;

        gameState.platforms = [
          {x: 40,  y: 330, width: 260, height: 25, type: 'ground'},
          {x: 360, y: 300, width: 160, height: 25, type: 'ground'},
          {x: 590, y: 260, width: 140, height: 25, type: 'ground'},
          {x: 800, y: 220, width: 120, height: 25, type: 'ground'},
          {x: 980, y: 260, width: 140, height: 25, type: 'ground'},
          {x: 1210,y: 300, width: 160, height: 25, type: 'ground'},
          {x: 1490,y: 330, width: 260, height: 25, type: 'ground'},
          {x: 1810,y: 300, width: 160, height: 25, type: 'ground'},
          {x: 2040,y: 260, width: 140, height: 25, type: 'ground'},
          {x: 2250,y: 220, width: 120, height: 25, type: 'ground'},
          {x: 2430,y: 260, width: 140, height: 25, type: 'ground'},
          {x: 2660,y: 300, width: 160, height: 25, type: 'ground'},
          {x: 2940,y: 330, width: 300, height: 25, type: 'ground'}
        ];

        gameState.brains = [
          {x: 410,  y: 260, collected: false},
          {x: 840,  y: 180, collected: false},
          {x: 1560, y: 290, collected: false},
          {x: 2275, y: 180, collected: false},
          {x: 2990, y: 290, collected: false}
        ];

        gameState.enemies = [
          {x: 605,  y: 245, width: 35, height: 35, velX: 1.45, minX: 590,  maxX: 730,  type: 'sentinel', alive: true},
          {x: 1225, y: 275, width: 35, height: 35, velX: 1.55, minX: 1210, maxX: 1370, type: 'nightmare', alive: true},
          {x: 1835, y: 275, width: 35, height: 35, velX: 1.55, minX: 1810, maxX: 1970, type: 'sentinel', alive: true},
          {x: 2100, y: 220, width: 30, height: 30, velY: 1.35, minY: 190, maxY: 285, type: 'vertical', alive: true},
          {x: 2665, y: 270, width: 30, height: 30, velX: 0, attackTimer: 34, attackRange: 440, type: 'ranged', alive: true},
          {x: 1495, y: 295, width: 35, height: 35, velX: 1.6, minX: 1490, maxX: 1750, type: 'nightmare', alive: true},
          {x: 2950, y: 295, width: 35, height: 35, velX: 1.65, minX: 2940, maxX: 3240, type: 'sentinel', alive: true}
        ];
      }

      // Apply difficulty tuning (keeps levels achievable, increases challenge gradually)
      applyDifficultyTuning(level);

      // Ensure every level has at least one moving platform (more + faster in later levels)
      setupMovingPlatformsForLevel(level);

      // Add a few extra enemies per level (more in later levels), keeping placements clean
      boostEnemiesForLevel(level);

      // Add end flag at the end of the level (place it on the last platform for fairness)
      if (gameState.platforms && gameState.platforms.length) {
        const lastPlatform = gameState.platforms.reduce((best, p) => {
          return (p.x + p.width > best.x + best.width) ? p : best;
        }, gameState.platforms[0]);
        gameState.endFlag = {
          x: Math.max(20, (lastPlatform.x + lastPlatform.width) - 40),
          y: (lastPlatform.y - 80),
          width: 30,
          height: 80
        };
      } else {
        gameState.endFlag = {x: gameState.levelWidth - 100, y: 270, width: 30, height: 80};
      }

      
      initEchidnaNPC(level);

// Cleanup pass after adding features
      snapEnemiesToPlatforms();
      separateEnemiesX(55);
      liftBrainsOutFromUnderPlatforms();

    }

    // Difficulty + layout cleanup pass (keeps levels logical, prevents overlaps)
    function applyDifficultyAndCleanup(levelNum) {
      // 1) Add a few extra enemies on existing platforms (scales up gently)
      const extraEnemies = Math.max(0, levelNum - 2); // L1-2 none, then +1 per level
      spawnExtraEnemiesOnPlatforms(extraEnemies, levelNum);

      // 2) Ensure enemies are standing on top of a platform and not overlapping
      snapEnemiesToPlatforms();
      separateEnemiesX(55);

      // 3) Ensure brains/questions are not hidden under platforms
      liftBrainsOutFromUnderPlatforms();

      // 4) Late-game platform tightening (small change only, keeps achievable)
      if (levelNum >= 8) {
        tightenSomePlatforms(2, 30); // shrink a couple of wide platforms a bit
      }
    }

    function spawnExtraEnemiesOnPlatforms(count, levelNum) {
      if (!gameState.platforms || !gameState.platforms.length) return;
      const candidates = gameState.platforms
        .filter(p => p.width >= 140 && p.x > 250 && p.x < gameState.levelWidth - 250)
        .sort(() => Math.random() - 0.5);

      for (let i = 0; i < count; i++) {
        const plat = candidates[i % candidates.length];
        if (!plat) break;

        const enemyW = 35, enemyH = 35;
        // Place within platform bounds with padding
        const minX = plat.x + 10;
        const maxX = plat.x + plat.width - enemyW - 10;
        if (maxX <= minX) continue;

        // pick an x that doesn't collide with existing enemies
        let x = minX + Math.random() * (maxX - minX);
        let tries = 10;
        while (tries-- > 0 && gameState.enemies.some(e => Math.abs((e.x + e.width/2) - (x + enemyW/2)) < 60 && Math.abs(e.y - (plat.y - enemyH)) < 25)) {
          x = minX + Math.random() * (maxX - minX);
        }

        gameState.enemies.push({
          x,
          y: plat.y - enemyH,
          width: enemyW,
          height: enemyH,
          velX: (Math.random() < 0.5 ? -1 : 1) * (levelNum >= 6 ? 2.0 : 1.6),
          minX,
          maxX,
          alive: true
        });
      }
    }

    function snapEnemiesToPlatforms() {
      if (!gameState.platforms || !gameState.enemies) return;
      gameState.enemies.forEach(e => {
        // Find platform under enemy centre
        const cx = e.x + e.width / 2;
        const plat = gameState.platforms.find(p => cx >= p.x && cx <= (p.x + p.width) && e.y + e.height <= p.y + 8);
        if (plat) {
          e.y = plat.y - e.height;
          e.minX = plat.x + 10;
          e.maxX = plat.x + plat.width - e.width - 10;
          if (e.maxX < e.minX) {
            e.minX = plat.x;
            e.maxX = plat.x + Math.max(0, plat.width - e.width);
          }
          // clamp x
          e.x = Math.min(Math.max(e.x, e.minX), e.maxX);
        } else {
          // If no platform, try to snap to nearest platform by x distance
          let best = null;
          let bestDist = Infinity;
          for (const p of gameState.platforms) {
            const px = p.x + p.width / 2;
            const d = Math.abs(px - cx);
            if (d < bestDist) { bestDist = d; best = p; }
          }
          if (best) {
            e.y = best.y - e.height;
            e.minX = best.x + 10;
            e.maxX = best.x + best.width - e.width - 10;
            e.x = Math.min(Math.max(best.x + 20, e.minX), e.maxX);
          }
        }
      });
    }

    function separateEnemiesX(minSep) {
      if (!gameState.enemies) return;
      for (let i = 0; i < gameState.enemies.length; i++) {
        for (let j = i + 1; j < gameState.enemies.length; j++) {
          const a = gameState.enemies[i];
          const b = gameState.enemies[j];
          if (Math.abs((a.x + a.width/2) - (b.x + b.width/2)) < minSep && Math.abs(a.y - b.y) < 30) {
            b.x += minSep;
            // clamp to patrol bounds if present
            if (typeof b.minX === 'number' && typeof b.maxX === 'number') {
              b.x = Math.min(Math.max(b.x, b.minX), b.maxX);
            }
          }
        }
      }
    }

    function liftBrainsOutFromUnderPlatforms() {
      if (!gameState.brains || !gameState.platforms) return;
      gameState.brains.forEach(br => {
        // If brain intersects a platform vertically (hidden under), lift it above that platform
        for (const p of gameState.platforms) {
          const overlapsX = (br.x + br.width) > p.x && br.x < (p.x + p.width);
          const underTop = (br.y + br.height) > p.y && br.y < (p.y + p.height + 9999);
          if (overlapsX && underTop && br.y > p.y - 5) {
            br.y = p.y - br.height - 10;
          }
        }
      });
    }


    // Ensure each level has intentional moving platforms (no messy overlap add-ons)
    function setupMovingPlatformsForLevel(level) {
      const P = gameState.platforms || [];
      if (!P.length) return;

      const maxIdx = P.length - 1;
      const clampIdx = (i) => Math.max(0, Math.min(maxIdx, i));

      // Helper: apply movement to an existing platform, oscillating around its starting point.
      function makeMoving(idx, cfg) {
        idx = clampIdx(idx);
        // Avoid converting the last platform (flag platform) into a mover.
        if (idx === maxIdx) idx = clampIdx(idx - 1);

        const p = P[idx];
        if (!p) return;

        // Optional: make platform smaller on harder levels for more challenge (still fair).
        if (typeof cfg.width === 'number') {
          p.width = Math.max(70, Math.round(cfg.width));
        }

        // Horizontal motion
        if (typeof cfg.vx === 'number' && cfg.vx !== 0) {
          const range = Math.max(30, cfg.rangeX ?? 70);
          p.vx = cfg.vx;
          p.minX = (cfg.centerX ?? p.x) - range;
          p.maxX = (cfg.centerX ?? p.x) + range;
        }

        // Vertical motion
        if (typeof cfg.vy === 'number' && cfg.vy !== 0) {
          const rangeY = Math.max(25, cfg.rangeY ?? 50);
          p.vy = cfg.vy;
          p.minY = (cfg.centerY ?? p.y) - rangeY;
          p.maxY = (cfg.centerY ?? p.y) + rangeY;

          // Keep movers within the playable vertical band
          p.minY = Math.max(120, p.minY);
          p.maxY = Math.min(330, p.maxY);
        }

        p.isMoving = true;
      }

      // Clear any previous mover props (safety when retrying levels)
      for (const p of P) {
        delete p.vx; delete p.vy; delete p.minX; delete p.maxX; delete p.minY; delete p.maxY; delete p.isMoving;
      }

      // Per-level moving platform plan: at least one mover every level, more + faster later.
      switch (level) {
        case 1:
          makeMoving(3, { vx: 0.75, rangeX: 55 }); // gentle intro mover
          break;
        case 2:
          makeMoving(4, { vx: 0.9, rangeX: 75 });
          break;
        case 3:
          makeMoving(5, { vy: 0.6, rangeY: 45 });
          break;
        case 4:
          makeMoving(3, { vx: 1.05, rangeX: 90, width: 125 });
          makeMoving(7, { vy: 0.75, rangeY: 55, width: 115 });
          break;
        case 5:
          makeMoving(2, { vx: 1.15, rangeX: 110, width: 110 });
          makeMoving(6, { vy: 0.85, rangeY: 60, width: 105 });
          break;
        case 6:
          makeMoving(3, { vx: 1.2, rangeX: 120, width: 110 });
          makeMoving(6, { vx: 0.95, rangeX: 80, width: 130 });
          makeMoving(8, { vx: 1.0, rangeX: 95, width: 105 });
          break;
        case 7:
          makeMoving(2, { vx: 1.25, rangeX: 130, width: 105 });
          makeMoving(5, { vy: 0.95, rangeY: 70, width: 95 });
          makeMoving(8, { vx: 1.05, rangeX: 95, width: 120 });
          break;
        case 8:
          makeMoving(2, { vx: 1.35, rangeX: 140, width: 95 });
          makeMoving(5, { vy: 1.05, rangeY: 80, width: 90 });
          makeMoving(7, { vx: 1.15, rangeX: 110, width: 105 });
          break;
        case 9:
          makeMoving(1, { vx: 1.35, rangeX: 150, width: 95 });
          makeMoving(4, { vy: 1.1, rangeY: 85, width: 90 });
          makeMoving(7, { vx: 1.25, rangeX: 120, width: 95 });
          break;
        case 10:
          makeMoving(1, { vx: 1.4, rangeX: 160, width: 90 });
          makeMoving(4, { vy: 1.15, rangeY: 90, width: 85 });
          makeMoving(7, { vx: 1.3, rangeX: 130, width: 90 });
          break;
        default:
          makeMoving(3, { vx: 1.0, rangeX: 80 });
      }
    }

    // Add a small number of extra enemies per level (more in later levels), without overlap or under-platform spawns.
    function boostEnemiesForLevel(level) {
      const P = gameState.platforms || [];
      if (!P.length) return;

      gameState.enemies = gameState.enemies || [];

      const extra =
        (level <= 3) ? 1 :
        (level <= 6) ? 2 :
        (level <= 8) ? 3 : 4;

      // Pick spaced platform indices so enemies are distributed, not clumped
      const picksByLevel = {
        1: [5],
        2: [4],
        3: [3],
        4: [2, 6],
        5: [2, 6],
        6: [2, 5, 8],
        7: [2, 5, 8],
        8: [2, 5, 7, 9],
        9: [2, 5, 7, 9],
        10:[2, 5, 7, 9]
      };

      const picks = (picksByLevel[level] || [2, 6, 8]).slice(0, extra);

      function enemyTypeForPlatform(plat) {
        const t = plat.type || 'ground';
        if (t === 'magma') return 'ice';
        if (t === 'ice') return 'nightmare';
        if (t === 'dark') return 'ice';
        return 'sentinel';
      }

      for (const idx of picks) {
        const i = Math.max(0, Math.min(P.length - 2, idx)); // avoid last platform
        const plat = P[i];
        if (!plat || plat.width < 110) continue;

        // Place enemy with patrol bounds inside platform
        const margin = 12;
        const minX = plat.x + margin;
        const maxX = plat.x + plat.width - (35 + margin);
        if (maxX <= minX + 35) continue;

        const type = enemyTypeForPlatform(plat);
        const speed = 1.0 + (level * 0.07);

        gameState.enemies.push({
          x: (minX + maxX) / 2,
          y: plat.y - 35,
          width: 35,
          height: 35,
          velX: Math.min(2.2, speed),
          minX,
          maxX,
          type,
          alive: true
        });
      }
    }
    // --- Friendly NPC: Echidna encouragement (non-intrusive) ---
    const ECHIDNA_LINES = [
      "Good luck getting home!",
      "Keep going!",
      "You‚Äôve got this!",
      "Nice work!",
      "Almost there!",
      "So close!",
      "Well done!",
      "Onward!",
      "Don‚Äôt give up!",
      "Home is close!"
    ];

    function initEchidnaNPC(level){
      // Place echidna on/near the first real platform (not the full-width floor)
      const plats = (gameState.platforms || []).filter(p => p.width < gameState.levelWidth - 50);
      plats.sort((a,b)=>a.x-b.x);
      const anchor = plats.length ? plats[0] : (gameState.platforms && gameState.platforms[0]);
      if(!anchor){
        gameState.npc = null;
        return;
      }
      const msg = ECHIDNA_LINES[(level - 1) % ECHIDNA_LINES.length];
      gameState.npc = {
        x: anchor.x + Math.min(90, Math.max(40, anchor.width * 0.35)),
        y: anchor.y - 26,
        baseY: anchor.y - 26,
        wasClose: false,
        cooldownUntil: 0,
        bounceVel: null,
        w: 34,
        h: 22,
        message: msg,
        shown: false,
        showUntil: 0
      };
    }

    function updateEchidnaNPC(){
      const npc = gameState.npc;
      const player = gameState.player;
      if(!npc || !player) return;

      const now = performance.now();

      // Trigger when player ENTERS range (works both directions), with a small cooldown
      const dist = Math.abs((player.x + player.width/2) - (npc.x + npc.w/2));
      const closeEnough = dist < 140 && Math.abs(player.y - npc.y) < 120;

      if(closeEnough && !npc.wasClose && now >= (npc.cooldownUntil || 0)){
        npc.showUntil = now + 2500;     // 2.5s bubble
        npc.cooldownUntil = now + 900; // prevent spam if hovering
        npc.bounceVel = -4;            // friendly hop
        npc.shown = true;              // compatibility (in case anything checks this)
      }

      npc.wasClose = closeEnough;

      // Simple bounce physics back to baseY
      if(npc.bounceVel !== null){
        npc.y += npc.bounceVel;
        npc.bounceVel += 0.35;
        if(npc.y >= npc.baseY){
          npc.y = npc.baseY;
          npc.bounceVel = null;
        }
      }
    }
    function drawEchidnaNPC(cameraX){
      const npc = gameState.npc;
      if(!npc) return;

      const dx = npc.x - cameraX;
      const dy = npc.y;

      // Body (cute simple echidna)
      ctx.save();
      ctx.translate(dx, dy);

      // Shadow
      ctx.fillStyle = "rgba(0,0,0,0.18)";
      ctx.beginPath();
      ctx.ellipse(npc.w/2, npc.h-2, npc.w*0.42, npc.h*0.22, 0, 0, Math.PI*2);
      ctx.fill();

      // Spines
      ctx.strokeStyle = "#b89a6a";
      ctx.lineWidth = 2;
      for(let i=0;i<6;i++){
        const sx = 6 + i*4.5;
        ctx.beginPath();
        ctx.moveTo(sx, 8);
        ctx.lineTo(sx-2, 2);
        ctx.stroke();
      }

      // Body
      ctx.fillStyle = "#c8a36b";
      ctx.beginPath();
      ctx.ellipse(npc.w/2, npc.h/2+2, npc.w*0.45, npc.h*0.38, 0, 0, Math.PI*2);
      ctx.fill();

      // Face
      ctx.fillStyle = "#d8b47a";
      ctx.beginPath();
      ctx.ellipse(npc.w*0.72, npc.h*0.60, npc.w*0.18, npc.h*0.16, 0, 0, Math.PI*2);
      ctx.fill();

      // Nose
      ctx.fillStyle = "#2b2b2b";
      ctx.beginPath();
      ctx.arc(npc.w*0.83, npc.h*0.60, 2.2, 0, Math.PI*2);
      ctx.fill();

      // Eye
      ctx.beginPath();
      ctx.arc(npc.w*0.72, npc.h*0.52, 1.8, 0, Math.PI*2);
      ctx.fill();

      ctx.restore();

      // Speech bubble (only while active)
      if(npc.showUntil && performance.now() < npc.showUntil){
        const text = npc.message;
        ctx.save();
        ctx.font = "600 14px system-ui, -apple-system, Segoe UI, Roboto, Arial";
        const padX = 10, padY = 8;
        const metrics = ctx.measureText(text);
        const bw = Math.min(260, metrics.width + padX*2);
        const bh = 34;

        const bx = dx + npc.w/2 - bw/2;
        const by = dy - 44;

        // Bubble
        ctx.fillStyle = "rgba(10,30,60,0.72)";
        ctx.strokeStyle = "rgba(170,255,255,0.24)";
        ctx.lineWidth = 1;

        // rounded rect
        const r = 10;
        ctx.beginPath();
        ctx.moveTo(bx+r, by);
        ctx.lineTo(bx+bw-r, by);
        ctx.quadraticCurveTo(bx+bw, by, bx+bw, by+r);
        ctx.lineTo(bx+bw, by+bh-r);
        ctx.quadraticCurveTo(bx+bw, by+bh, bx+bw-r, by+bh);
        ctx.lineTo(bx+r, by+bh);
        ctx.quadraticCurveTo(bx, by+bh, bx, by+bh-r);
        ctx.lineTo(bx, by+r);
        ctx.quadraticCurveTo(bx, by, bx+r, by);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        // Tail
        ctx.beginPath();
        ctx.moveTo(dx + npc.w*0.60, dy - 10);
        ctx.lineTo(dx + npc.w*0.65, dy - 2);
        ctx.lineTo(dx + npc.w*0.50, dy - 4);
        ctx.closePath();
        ctx.fill();

        // Text
        ctx.fillStyle = "#e6f7ff";
        ctx.textAlign = "center";
        ctx.fillText(text, bx + bw/2, by + 22);

        ctx.restore();
      }
    }


    function tightenSomePlatforms(count, shrinkBy) {
      if (!gameState.platforms) return;
      const wides = gameState.platforms.filter(p => p.width >= 200).sort((a,b)=> (b.x - a.x));
      for (let i = 0; i < Math.min(count, wides.length); i++) {
        wides[i].width = Math.max(120, wides[i].width - shrinkBy);
      }
    }


    // Moving platforms: update positions + store deltas so the player can ride them
    function updateMovingPlatforms() {
      if (!gameState.platforms) return;
      for (const p of gameState.platforms) {
        p._dx = 0; p._dy = 0;
        if (typeof p.vx === 'number' || typeof p.vy === 'number') {
          const prevX = p.x, prevY = p.y;

          if (typeof p.vx === 'number') {
            p.x += p.vx;
            if (typeof p.minX === 'number' && typeof p.maxX === 'number') {
              if (p.x <= p.minX || p.x >= p.maxX) {
                p.vx *= -1;
                p.x = Math.min(Math.max(p.x, p.minX), p.maxX);
              }
            }
          }

          if (typeof p.vy === 'number') {
            p.y += p.vy;
            if (typeof p.minY === 'number' && typeof p.maxY === 'number') {
              if (p.y <= p.minY || p.y >= p.maxY) {
                p.vy *= -1;
                p.y = Math.min(Math.max(p.y, p.minY), p.maxY);
              }
            }
          }

          p._dx = p.x - prevX;
          p._dy = p.y - prevY;
        }
      }
    }

    // Game loop
    function gameLoop() {
      if (!gameState.gameActive) return;
      
      update();
      draw();
      
      requestAnimationFrame(gameLoop);
    }

    // Update game state with fixed physics
    function update() {
      const player = gameState.player;
      
      // Player is dead - wait for respawn
      if (gameState.isDead) {
        if (gameState.keys.r) {
          respawnPlayer();
        }
        return;
      }

      // Update moving platforms before collisions
      updateMovingPlatforms();

      // Apply gravity if not grounded
      if (!player.grounded) {
        player.velY += player.gravity;
      } else {
        player.velY = 0;
      }
      
      // Handle horizontal movement with friction
      if (gameState.keys.left) {
        player.velX = -player.speed;
        player.direction = -1;
      } else if (gameState.keys.right) {
        player.velX = player.speed;
        player.direction = 1;
      } else {
        player.velX *= player.friction;
        if (Math.abs(player.velX) < 0.1) player.velX = 0;
      }
      
      // Jumping - only when grounded
      if (gameState.keys.up && player.grounded) {
        player.velY = player.jumpPower;
        player.grounded = false;
        player.standingOn = null;
        playSfx('jump');
      }
      
      // Shooting
      if (gameState.keys.shoot && gameState.shootCooldown <= 0) {
        const projectile = {
x: player.x + player.width * player.direction,
          y: player.y + player.height/2,
          width: (player.element === "water") ? 20 : 15,
          height: (player.element === "water") ? 20 : 15,

          velX: 7 * player.direction,
          distance: 0,
          range: 400,
          element: player.element
        };
        
        // Special properties based on element
        if (player.element === "electric") {
          projectile.chain = 3; // Number of times it can chain
          projectile.damage = 2; // Base damage
        } else if (player.element === "fire") {
          projectile.explosionRadius = 60; // Explosion radius
          projectile.explosionDamage = 3; // Explosion damage
        }
        
        gameState.playerProjectiles.push(projectile);
        playSfx('shoot');
        gameState.shootCooldown = 60; // Cooldown frames
      }
      
      // Update position
      player.x += player.velX;
      player.y += player.velY;
      
      // Boundary checks (left/right)
      if (player.x < 0) {
        player.x = 0;
        player.velX = 0;
      }
      if (player.x > gameState.levelWidth - player.width) {
        player.x = gameState.levelWidth - player.width;
        player.velX = 0;
      }
      
      // Boundary check (bottom) - prevent falling through
      if (player.y > gameCanvas.height + 100) {
        playerDie();
        return;
      }
      
      // Improved platform collision detection (supports moving platforms)
      player.grounded = false;
      let groundedPlatform = null;

      // Ride moving platforms (single-source-of-truth):
      // Apply last frame platform delta AFTER grounded reset, so it can't be overwritten.
      if (player.standingOn && (player.standingOn._dx || player.standingOn._dy)) {
        const p = player.standingOn;
        const overlapX = (player.x + player.width > p.x) && (player.x < p.x + p.width);
        const eps = 10; // snap tolerance so we don't "fall through" when platform moves down
        const closeToTop = Math.abs((player.y + player.height) - p.y) <= eps;
        if (overlapX && closeToTop) {
          player.x += p._dx || 0;
          player.y += p._dy || 0;
          // treat as grounded unless a later collision proves otherwise
          player.grounded = true;
          groundedPlatform = p;
        }
      }

      for (const platform of gameState.platforms) {
        // Check if player is intersecting with platform vertically
        if (player.x < platform.x + platform.width &&
            player.x + player.width > platform.x &&
            player.y + player.height >= platform.y &&
            player.y < platform.y) {

          // Check if player was above the platform in previous frame
          if (player.y + player.height - player.velY <= platform.y) {
            player.y = platform.y - player.height;
            player.velY = 0;
            player.grounded = true;
            groundedPlatform = platform;
          }
        }
      }

      // Remember what we're standing on for next frame (used for moving platforms)
      player.standingOn = player.grounded ? groundedPlatform : null;

// Update camera position to follow player
      gameState.cameraX = player.x - gameCanvas.width / 2;
      gameState.cameraX = Math.max(0, Math.min(gameState.levelWidth - gameCanvas.width, gameState.cameraX));
      
      // Brain collection
      for (const brain of gameState.brains) {
        if (!brain.collected) {
          const dx = Math.abs(player.x + player.width/2 - (brain.x + 10));
          const dy = Math.abs(player.y + player.height/2 - (brain.y + 10));
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance < 20) {
            brain.collected = true;
              addPoints(SCORE.brain);
            gameState.collectedBrains.push(brain);
            gameState.levels[gameState.currentLevel-1].collected++;
            playSfx('collect');
          }
        }
      }
      
      // Update enemies
      for (const enemy of gameState.enemies) {
        if (enemy.alive) {
                    // If enemy is standing on a moving platform, ride it (prevents floating / weird hits)
          let enemyGround = null;
          for (const p of gameState.platforms) {
            if ((p._dx || p._dy) &&
                enemy.x < p.x + p.width && enemy.x + enemy.width > p.x &&
                Math.abs((enemy.y + enemy.height) - p.y) <= 3) {
              enemyGround = p;
              break;
            }
          }
          if (enemyGround) {
            enemy.x += enemyGround._dx || 0;
            enemy.y += enemyGround._dy || 0;
          }

// Move enemy based on type
          if (enemy.type === 'ground' || enemy.type === 'ice' || enemy.type === 'magma' || enemy.type === 'sentinel' || enemy.type === 'nightmare') {
            enemy.x += enemy.velX;
            if (enemy.x <= enemy.minX || enemy.x + enemy.width >= enemy.maxX) {
              enemy.velX *= -1;
            }
          }
          else if (enemy.type === 'vertical') {
            enemy.y += enemy.velY;
            if (enemy.y <= enemy.minY || enemy.y >= enemy.maxY) {
              enemy.velY *= -1;
            }
          }
          else if (enemy.type === 'ranged') {
            // Update attack timer
            enemy.attackTimer--;
            if (enemy.attackTimer <= 0) {
              // Calculate direction to player
              const dx = player.x - enemy.x;
              const dy = player.y - enemy.y;
              const distance = Math.sqrt(dx * dx + dy * dy);
              
              // Only shoot if player is in range
              if (distance < enemy.attackRange) {
                // Normalize direction
                const velX = dx / distance * 3;
                const velY = dy / distance * 3;
                
                // Create projectile
                gameState.enemyProjectiles.push({
                  x: enemy.x + enemy.width/2,
                  y: enemy.y + enemy.height/2,
                  width: 10,
                  height: 10,
                  velX: velX,
                  velY: velY,
                  distance: 0,
                  range: enemy.attackRange
                });
                
                // Reset attack timer
                enemy.attackTimer = 120;
              }
            }
          }
          
          // Enemy collision with player
          if (
            player.x < enemy.x + enemy.width &&
            player.x + player.width > enemy.x &&
            player.y < enemy.y + enemy.height &&
            player.y + player.height > enemy.y
          ) {
            // Check if player is jumping on enemy
            if (player.y + player.height < enemy.y + enemy.height/2 && player.velY > 0) {
              // Player lands on enemy
              playTone({ freq: 180, duration: 0.08, type: 'square', peak: 0.22, attack: 0.001, decay: 0.09 });
              enemy.alive = false;
            if(!enemy.scored){ enemy.scored = true; addPoints(SCORE.enemy); }

              player.velY = -10; // bounce
            } else {
              // Player touched enemy from side or below
              playerDie();
              return;
            }
          }
        }
      }
      
      // Update projectiles
      updateProjectiles();
      
      // End flag collision
      if (
        player.x < gameState.endFlag.x + gameState.endFlag.width &&
        player.x + player.width > gameState.endFlag.x &&
        player.y < gameState.endFlag.y + gameState.endFlag.height &&
        player.y + player.height > gameState.endFlag.y
      ) {
        endLevel();
      }

      updateEchidnaNPC();

      
      // Update shoot cooldown
      if (gameState.shootCooldown > 0) {
        gameState.shootCooldown--;
      }
    }
    
    // Update projectiles
function updateProjectiles() {
  // Player projectiles
  for (let i = gameState.playerProjectiles.length - 1; i >= 0; i--) {
    const p = gameState.playerProjectiles[i];
    p.x += p.velX;
    p.distance += Math.abs(p.velX);

    // Check enemy collisions
    let hit = false;
    for (const enemy of gameState.enemies) {
      if (
        enemy.alive &&
        p.x < enemy.x + enemy.width &&
        p.x + p.width > enemy.x &&
        p.y < enemy.y + enemy.height &&
        p.y + p.height > enemy.y
      ) {
        enemy.alive = false;
        hit = true;
        playSfx('hit');

        // === üî• Fire explosion effect ===
        if (p.element === "fire") {
          for (const e of gameState.enemies) {
            if (e.alive) {
              const dx = e.x - p.x;
              const dy = e.y - p.y;
              const distance = Math.sqrt(dx * dx + dy * dy);
              if (distance < p.explosionRadius) {
                e.alive = false;
              }
            }
          }

          // üí• Add explosion particles
          for (let j = 0; j < 15; j++) {
            gameState.particles.push({
              x: p.x,
              y: p.y,
              radius: 2 + Math.random() * 3,
              color: `rgba(255, ${100 + Math.floor(Math.random() * 100)}, 0, 0.7)`,
              vx: (Math.random() - 0.5) * 5,
              vy: (Math.random() - 0.5) * 5,
              life: 30 + Math.random() * 20
            });
          }

        } else if (p.element === "water") {
  // Create more visible water splash particles with high contrast
  for (let j = 0; j < 20; j++) {
    // 50/50 chance of very light or very dark blue
    const useDark = Math.random() < 0.5;
    const color = useDark
      ? `rgba(5, 10, 60, ${0.8 + Math.random() * 0.2})`   // VERY dark navy
      : `rgba(220, 245, 255, ${0.7 + Math.random() * 0.3})`; // almost white-blue

    gameState.particles.push({
      x: p.x,
      y: p.y,
      radius: useDark ? (2.5 + Math.random() * 3) : (1.5 + Math.random() * 2), // darker = bigger
      color: color,
      vx: (Math.random() - 0.5) * 5,
      vy: (Math.random() - 0.7) * 6,
      life: 20 + Math.random() * 15,
      type: 'water',
      gravity: 0.15,
      bounce: 0.5,
      trail: []
    });
  }

       } else if (p.element === "electric") {
  for (const e of gameState.enemies) {
    if (e.alive) {
      const dx = e.x - p.x;
      const dy = e.y - p.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      if (distance < p.explosionRadius) {
        e.alive = false;
      }
    }
  }

  // ‚ö° Electric explosion particles (similar to fire but yellow/white)
  for (let j = 0; j < 15; j++) {
    gameState.particles.push({
      x: p.x,
      y: p.y,
      radius: 2 + Math.random() * 3,
      color: `rgba(255, ${220 + Math.floor(Math.random() * 35)}, 0, 0.8)`, // yellow/orange
      vx: (Math.random() - 0.5) * 5,
      vy: (Math.random() - 0.5) * 5,
      life: 20 + Math.random() * 20
    });
  }
}

        break; // only affect one enemy
      }
    }

    // Remove projectiles that hit or exceeded range
    if (hit || p.distance > p.range) {
      gameState.playerProjectiles.splice(i, 1);
    }
  }
      
      // Enemy projectiles
      for (let i = gameState.enemyProjectiles.length - 1; i >= 0; i--) {
        const p = gameState.enemyProjectiles[i];
        p.x += p.velX;
        p.y += p.velY;
        p.distance += Math.sqrt(p.velX * p.velX + p.velY * p.velY);
        
        // Check player collision
        const player = gameState.player;
        if (p.x < player.x + player.width &&
            p.x + p.width > player.x &&
            p.y < player.y + player.height &&
            p.y + p.height > player.y) {
          playerDie();
          gameState.enemyProjectiles.splice(i, 1);
        } 
        // Remove projectiles that exceed range
        else if (p.distance > p.range) {
          gameState.enemyProjectiles.splice(i, 1);
        }
      }
    }

    function playerDie() {
      if (gameState.player.lives <= 0) return;

      playSfx('die');
      gameState.player.lives--;

      if (gameState.player.lives <= 0) {
        applyWipePenalty();

        gameState.player.lives = 0;
        showRestartMessage("üíÄ Out of lives! Restarting level...");

        setTimeout(() => {
          // Reset player state
          gameState.player.lives = 3;
          gameState.player.brains = 0;
          gameState.brainsCollected = 0;
          gameState.collectedBrains = [];

          // ‚úÖ Safely reset visual counter only if it's visible
          const counterEl = document.getElementById("collectedCount");
          if (counterEl) counterEl.textContent = "0";

          gameState.quizUnlocked = false;
          gameState.brainsNeeded = (gameState.level === 3) ? 15 : 10;

          // Reset player position and velocity
          const player = gameState.player;
          player.x = 100;
          player.y = 300;
          player.velX = 0;
          player.velY = 0;
          player.grounded = false;

          // Reset collected brains
          gameState.brains.forEach(brain => brain.collected = false);

          hideRestartMessage();
          setupLevel(gameState.currentLevel);
        }, 2000);

      } else {
        respawnPlayer();
      }
    }

    function showRestartMessage(message) {
      let msg = document.getElementById('restartMessage');
      if (!msg) {
        msg = document.createElement('div');
        msg.id = 'restartMessage';
        msg.style.position = 'absolute';
        msg.style.top = '40%';
        msg.style.left = '50%';
        msg.style.transform = 'translate(-50%, -50%)';
        msg.style.background = '#fff';
        msg.style.border = '2px solid #000';
        msg.style.padding = '20px';
        msg.style.fontSize = '20px';
        msg.style.zIndex = 1000;
        msg.style.color = '#000';
        msg.style.maxWidth = '90%';
        msg.style.textAlign = 'center';
        document.body.appendChild(msg);
      }
      msg.textContent = message;
      msg.style.display = 'block';
    }

    function hideRestartMessage() {
      const msg = document.getElementById('restartMessage');
      if (msg) msg.style.display = 'none';
    }

    function respawnPlayer() {
      const player = gameState.player;
      player.x = 100;
      player.y = 300;
      player.velX = 0;
      player.velY = 0;
      player.grounded = false;
      gameState.isDead = false;
      deathOverlay.style.opacity = '0';
      setTimeout(() => {
        deathOverlay.style.display = 'none';
      }, 300);
    }

    // Draw everything
    function draw() {
      const cameraX = gameState.cameraX;
      
      // Clear canvas
      ctx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
      
      // Draw background - pass current level
      drawBackground(cameraX, gameState.currentLevel);
      
      // Draw platforms
for (const platform of gameState.platforms) {
  const dx = platform.x - cameraX;

  // Base color by type
  if (platform.type === 'ice') {
    ctx.fillStyle = '#aaffff';
  } else if (platform.type === 'magma') {
    ctx.fillStyle = '#ff6600';
  } else if (platform.type === 'green') {
    ctx.fillStyle = '#aaffaa';
  } else if (platform.type === 'dark') {
    ctx.fillStyle = '#4a4f57';
  } else {
    ctx.fillStyle = '#8B4513'; // default/ground
  }
  ctx.fillRect(dx, platform.y, platform.width, platform.height);

  // Top edge strip (slightly darker)
  if (platform.type === 'ice') {
    ctx.fillStyle = '#66ccff';
  } else if (platform.type === 'magma') {
    ctx.fillStyle = '#cc3300';
  } else if (platform.type === 'green') {
    ctx.fillStyle = '#66cc66';
  } else if (platform.type === 'dark') {
    ctx.fillStyle = '#2b3138';
  } else {
    ctx.fillStyle = '#A0522D';
  }
  ctx.fillRect(dx, platform.y, platform.width, 5);
}
      
      // Draw brains
for (const brain of gameState.brains) {
  if (!brain.collected) {
    ctx.fillStyle = '#FF66CC';
    ctx.beginPath();
    ctx.arc(brain.x - cameraX + 10, brain.y + 10, 10, 0, Math.PI * 2);
    ctx.fill();

    // Save before changing font/align
    ctx.save();

    ctx.fillStyle = '#FFFFFF';
    ctx.font = "bold 14px Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("?", brain.x - cameraX + 10, brain.y + 10);

    // Restore so HUD isn‚Äôt affected
    ctx.restore();
  }
}
      
      // Draw friendly NPC
      drawEchidnaNPC(cameraX);

      // Draw enemies
      for (const enemy of gameState.enemies) {
        if (enemy.alive) {
          // Draw enemy based on type
          if (enemy.type === 'ice') {
            ctx.fillStyle = '#88ddff';
          } else if (enemy.type === 'magma') {
            ctx.fillStyle = '#ff8844';
          } else if (enemy.type === 'nightmare') {
            ctx.fillStyle = '#cc88ff';
          } else if (enemy.type === 'sentinel') {
            ctx.fillStyle = '#aaddaa';
          } else {
            ctx.fillStyle = '#FF0000';
          }
          
          ctx.fillRect(enemy.x - cameraX, enemy.y, enemy.width, enemy.height);
          
          // Draw enemy eyes
          ctx.fillStyle = 'white';
          ctx.beginPath();
          const eyeOffset = (enemy.type === 'ground' && enemy.velX > 0) ? 8 : 2;
          ctx.arc(enemy.x - cameraX + eyeOffset, enemy.y + 10, 4, 0, Math.PI * 2);
          ctx.arc(enemy.x - cameraX + enemy.width - eyeOffset, enemy.y + 10, 4, 0, Math.PI * 2);
          ctx.fill();
          
          ctx.fillStyle = 'black';
          ctx.beginPath();
          ctx.arc(enemy.x - cameraX + eyeOffset, enemy.y + 10, 2, 0, Math.PI * 2);
          ctx.arc(enemy.x - cameraX + enemy.width - eyeOffset, enemy.y + 10, 2, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      drawProjectileEffects(ctx);

      for (const p of gameState.playerProjectiles) {
  const px = p.x - cameraX;
  const py = p.y;

  // === BASE COLOR ===
  if (p.element === "electric") {
    ctx.fillStyle = '#ffff33'; // bright electric yellow
  } else if (p.element === "fire") {
    ctx.fillStyle = '#ff5500'; // bright fire core
  } else {
    ctx.fillStyle = '#33ddff'; // vibrant aqua
  }

  // === BASE CIRCLE ===
  ctx.beginPath();
  ctx.arc(px, py, p.width / 2, 0, Math.PI * 2);
  ctx.fill();

  // === FIRE EFFECTS ===
  if (p.element === "fire") {
    // Big flame burst
    for (let i = 0; i < 5; i++) {
      const fx = px + (Math.random() - 0.5) * 10;
      const fy = py - Math.random() * 10;
      const r = 2 + Math.random() * 4;
      ctx.beginPath();
      ctx.fillStyle = `rgba(255, ${120 + Math.random() * 130}, 0, ${0.5 + Math.random() * 0.4})`;
      ctx.arc(fx, fy, r, 0, Math.PI * 2);
      ctx.fill();
    }

    // Glowing heat aura
    ctx.beginPath();
    ctx.arc(px, py, p.width / 2 + 5, 0, Math.PI * 2);
    ctx.strokeStyle = 'rgba(255, 100, 0, 0.2)';
    ctx.lineWidth = 4;
    ctx.stroke();
  }

  // === ELECTRIC EFFECTS ===
if (p.element === "electric") {
  // Electric pulse glow
  ctx.beginPath();
  ctx.arc(px, py, p.width / 2 + 5 + Math.sin(Date.now() / 100) * 2, 0, Math.PI * 2);
  ctx.strokeStyle = 'rgba(255, 255, 150, 0.4)';
  ctx.lineWidth = 3;
  ctx.stroke();

  // Sharp electric arcs
  ctx.strokeStyle = 'rgba(255, 255, 100, 0.7)';
  ctx.lineWidth = 1.2;
  for (let i = 0; i < 3; i++) {
    let x = px;
    let y = py;
    ctx.beginPath();
    ctx.moveTo(x, y);
    for (let j = 0; j < 4; j++) {
      x += (Math.random() - 0.5) * 12;
      y += (Math.random() - 0.5) * 12;
      ctx.lineTo(x, y);
    }
    ctx.stroke();
  }

  // Static pulse sparks
  for (let i = 0; i < 4; i++) {
    const ex = px + (Math.random() - 0.5) * 16;
    const ey = py + (Math.random() - 0.5) * 16;
    ctx.beginPath();
    ctx.fillStyle = 'rgba(255, 255, 100, 0.4)';
    ctx.arc(ex, ey, 1 + Math.random(), 0, Math.PI * 2);
    ctx.fill();
  }
}


  // === WATER EFFECTS ===
if (p.element === "water") {
  // Ripple aura (animated)
  const rippleRadius = p.width / 2 + 3 + Math.sin(Date.now() / 150) * 2;
  ctx.beginPath();
  ctx.arc(px, py, rippleRadius, 0, Math.PI * 2);
  ctx.strokeStyle = 'rgba(127, 216, 255, 0.3)';
  ctx.lineWidth = 2;
  ctx.stroke();

  // Bubble trail
  for (let i = 0; i < 2; i++) {
    const bubbleX = px - p.velX * i + (Math.random() - 0.5) * 4;
    const bubbleY = py + (Math.random() - 0.5) * 6;
    ctx.beginPath();
    ctx.fillStyle = 'rgba(127, 216, 255, 0.4)';
    ctx.arc(bubbleX, bubbleY, 1.5 + Math.random(), 0, Math.PI * 2);
    ctx.fill();
  }

  // Soft glow
  ctx.beginPath();
  ctx.arc(px, py, p.width / 2 + 4, 0, Math.PI * 2);
  ctx.strokeStyle = 'rgba(127, 216, 255, 0.2)';
  ctx.lineWidth = 3;
  ctx.stroke();
}
        }




      
      // Draw enemy projectiles
      for (const p of gameState.enemyProjectiles) {
        ctx.fillStyle = '#FFA500';
        ctx.beginPath();
        ctx.arc(p.x - cameraX, p.y, p.width/2, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Draw end flag
      ctx.fillStyle = '#4CAF50';
      ctx.fillRect(gameState.endFlag.x - cameraX, gameState.endFlag.y, 5, gameState.endFlag.height);
      
      ctx.fillStyle = '#2196F3';
      ctx.beginPath();
      ctx.moveTo(gameState.endFlag.x - cameraX + 5, gameState.endFlag.y);
      ctx.lineTo(gameState.endFlag.x - cameraX + 25, gameState.endFlag.y + 15);
      ctx.lineTo(gameState.endFlag.x - cameraX + 5, gameState.endFlag.y + 30);
      ctx.closePath();
      ctx.fill();
      
      // === PLAYER DRAW ===
const player = gameState.player;
const drawX = player.x - cameraX;
const drawY = player.y;
const centerX = drawX + player.width / 2;
const centerY = drawY + player.height / 2;

// === BASE COLOR ===
if (player.element === "electric") {
  ctx.fillStyle = '#666600'; // dark olive base for electric (your favorite)
} else if (player.element === "fire") {
  ctx.fillStyle = '#cc3300'; // locked-in fire base (deep red-orange)
} else {
  ctx.fillStyle = '#2aa8e6'; // aqua default
}

// === BODY ===
ctx.beginPath();
ctx.arc(centerX, centerY, player.width / 2, 0, Math.PI * 2);
ctx.fill();

// === ELEMENT EFFECTS ===

// üî• FIRE EFFECT ‚Äî locked in
if (player.element === "fire") {
  for (let i = 0; i < 6; i++) {
    const fx = centerX + (Math.random() - 0.5) * 10;
    const fy = centerY + (Math.random() - 1) * 18;
    const r = 5 + Math.random() * 4;
    const alpha = 0.3 + Math.random() * 0.3;
    ctx.beginPath();
    ctx.fillStyle = `rgba(255, ${80 + Math.random() * 80}, 0, ${alpha})`;
    ctx.arc(fx, fy, r, 0, Math.PI * 2);
    ctx.fill();
  }
}

// ‚ö° ELECTRIC EFFECT 
if (player.element === "electric") {
  // Soft yellow outer glow
  ctx.beginPath();
  ctx.arc(centerX, centerY, player.width / 2 + 4, 0, Math.PI * 2);
  ctx.strokeStyle = 'rgba(255, 255, 100, 0.25)';
  ctx.lineWidth = 4;
  ctx.stroke();

  // Electric spark lines (jagged)
  ctx.strokeStyle = '#ffff66'; // pale yellow sparks
  ctx.lineWidth = 1.5;
  for (let i = 0; i < 3; i++) {
    let x = centerX + (Math.random() - 0.5) * 15;
    let y = centerY + (Math.random() - 0.5) * 15;
    ctx.beginPath();
    ctx.moveTo(centerX, centerY);
    for (let j = 0; j < 3; j++) {
      x += (Math.random() - 0.5) * 6;
      y += (Math.random() - 0.5) * 6;
      ctx.lineTo(x, y);
    }
    ctx.stroke();
  }
}

// üíß WATER EFFECT (default)
if (!player.element || player.element === "water") {
  ctx.beginPath();
  ctx.arc(centerX, centerY, player.width / 2 + 3, 0, Math.PI * 2);
  ctx.strokeStyle = 'rgba(127, 216, 255, 0.2)';
  ctx.lineWidth = 2;
  ctx.stroke();

  ctx.beginPath();
  ctx.arc(centerX, centerY, player.width / 2 + 6, 0, Math.PI * 2);
  ctx.strokeStyle = 'rgba(127, 216, 255, 0.1)';
  ctx.lineWidth = 1.5;
  ctx.stroke();
}



// === TAIL with wiggle ===
ctx.beginPath();
const now = performance.now();
const isMoving = gameState.keys.left || gameState.keys.right;
const tailDirection = -player.direction || 1;
const wiggleY = isMoving ? Math.sin(now / 100) * 5 : 0;
const baseX = centerX + tailDirection * player.width / 2;
const baseY = centerY + wiggleY;

ctx.moveTo(baseX, baseY);
ctx.lineTo(baseX + tailDirection * player.width / 2, baseY);
ctx.lineTo(baseX + tailDirection * player.width / 3, drawY + player.height + wiggleY / 2);
ctx.closePath();
ctx.fill();

// === EYES ===
ctx.fillStyle = 'white';
ctx.beginPath();
ctx.arc(
  drawX + player.width / 3 + (player.direction > 0 ? player.width / 3 : 0),
  drawY + player.height / 3,
  4, 0, Math.PI * 2
);
ctx.fill();

ctx.fillStyle = 'black';
ctx.beginPath();
ctx.arc(
  drawX + player.width / 3 + (player.direction > 0 ? player.width / 3 : 0),
  drawY + player.height / 3,
  2, 0, Math.PI * 2
);
ctx.fill();




      
      // Draw collected brain counter
      ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
      ctx.fillRect(10, 10, 180, 40);
      
      ctx.fillStyle = 'white';
      ctx.font = '16px Arial';
      ctx.fillText(`Questions: ${gameState.collectedBrains.length}/${gameState.levels[gameState.currentLevel-1].brains}`, 20, 35);

      // Score (persistent across levels)
      ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
      ctx.fillRect(10, 55, 180, 40);
      ctx.fillStyle = 'white';
      ctx.font = '16px Arial';
      ctx.fillText(`Score: ${gameState.points}`, 20, 80);
      
      // Draw level indicator
      ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
      ctx.fillRect(gameCanvas.width - 190, 10, 180, 40);
      
      ctx.fillStyle = 'white';
      ctx.font = '16px Arial';
      ctx.fillText(`Level: ${gameState.currentLevel}`, gameCanvas.width - 180, 35);
      
      // Draw lives
      ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
      ctx.fillRect(gameCanvas.width/2 - 60, 10, 120, 40);
      
      ctx.fillStyle = 'white';
      ctx.font = '16px Arial';
      ctx.fillText(`Lives: ${gameState.player.lives}`, gameCanvas.width/2 - 50, 35);
    }

    function drawBackground(cameraX, level) {
  switch (level) {
    case 1: // Stormy Mountain
      drawStormyMountainBackground(cameraX);
      break;

    case 2: // Snow Forest
      drawForestBackground(cameraX, "snow");
      break;

    case 3: // Caves (reuse volcano/cavern art)
      drawVolcanoBackground(cameraX);
      break;

    case 4: // Haunted Swamp
      drawHauntedSwampBackground(cameraX, true);
      break;

    case 5: // Rainy Forest
      drawForestBackground(cameraX, "rain");
      break;

    case 6: // Lake (calm biolake, not haunted)
      drawBiolakeBackground(cameraX, false);
      break;

    case 7: // City
      drawCityBackground(cameraX);
      break;

    case 8: // City Ruins (using city art for now)
      drawTempleRuinsBackground(cameraX);
      break;

    case 9: // Alien World
      drawAlienBackground(cameraX);
      break;

    case 10: // Pond: Coming Home
      drawPondBackground(cameraX);
      break;

    default:
      drawDefaultBackground(cameraX);
  }
}

// ---- Storm constants (tweak as you like) ----
const STORM_SNOW_INTENSITY = 70;  // 0‚Äì100 (% of maxSnowParticles used)
const STORM_WIND_INTENSITY = 40;  // 0‚Äì100 (50 = neutral, <50 left, >50 right)
const STORM_INTENSITY      = 30;  // 0‚Äì100 (controls wind lines visibility)

// Draw stormy mountain background
function drawStormyMountainBackground(cameraX = 0) {
  // Sky gradient (dark stormy colors)
  const skyGradient = ctx.createLinearGradient(0, 0, 0, gameCanvas.height);
  skyGradient.addColorStop(0, '#2c3e50');
  skyGradient.addColorStop(0.6, '#34495e');
  skyGradient.addColorStop(1, '#1a2530');
  ctx.fillStyle = skyGradient;
  ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);

  // Distant storm clouds
  ctx.fillStyle = 'rgba(44, 62, 80, 0.7)';
  for (let i = 0; i < 8; i++) {
    const x = (i * 200 - cameraX * 0.1) % (gameCanvas.width + 400);
    const y = 50 + Math.sin(i) * 20;
    const width  = 180 + Math.sin(i * 2) * 30;
    const height = 60  + Math.cos(i)     * 15;

    ctx.beginPath();
    ctx.ellipse(x, y, width, height, 0, 0, Math.PI * 2);
    ctx.fill();
  }

  // Distant mountains (parallax)
  ctx.fillStyle = 'rgba(52, 73, 94, 0.8)';
  ctx.beginPath();
  ctx.moveTo(0 - cameraX * 0.2, gameCanvas.height);
  for (let i = 0; i < 20; i++) {
    const x = i * 150 - cameraX * 0.2;
    const h = 100 + Math.sin(i * 0.7) * 60;
    ctx.lineTo(x, gameCanvas.height - h);
  }
  ctx.lineTo(gameCanvas.width, gameCanvas.height);
  ctx.fill();

  // Closer mountains
  ctx.fillStyle = 'rgba(44, 62, 80, 0.9)';
  ctx.beginPath();
  ctx.moveTo(0 - cameraX * 0.5, gameCanvas.height);
  for (let i = 0; i < 15; i++) {
    const x = i * 200 - cameraX * 0.5;
    const h = 150 + Math.cos(i * 0.5) * 70;
    ctx.lineTo(x, gameCanvas.height - h);
  }
  ctx.lineTo(gameCanvas.width, gameCanvas.height);
  ctx.fill();

  // Snow caps on mountains
  ctx.fillStyle = 'rgba(236, 240, 241, 0.7)';
  ctx.beginPath();
  ctx.moveTo(0 - cameraX * 0.5, gameCanvas.height - 100);
  for (let i = 0; i < 15; i++) {
    const x = i * 200 - cameraX * 0.5;
    const h = 30 + Math.sin(i) * 15;
    ctx.lineTo(x, gameCanvas.height - 150 - h);
  }
  ctx.lineTo(gameCanvas.width, gameCanvas.height - 100);
  ctx.lineTo(gameCanvas.width, gameCanvas.height);
  ctx.lineTo(0, gameCanvas.height);
  ctx.fill();

  // ---- Snow particles ----
  const intensity = STORM_SNOW_INTENSITY / 100;
  const wind = (STORM_WIND_INTENSITY - 50) / 50 * 2; // -2..+2

  const count = Math.floor(maxSnowParticles * intensity);
  for (let i = 0; i < count; i++) {
    const particle = snowParticles[i];
    if (!particle) continue;

    // Update
    particle.y += particle.speed;
    particle.x += particle.wind + wind;

    // Wrap
    if (particle.y > gameCanvas.height) {
      particle.y = -10;
      particle.x = Math.random() * gameCanvas.width;
    }
    if (particle.x > gameCanvas.width + 10) particle.x = -10;
    if (particle.x < -10) particle.x = gameCanvas.width + 10;

    // Draw flake
    ctx.fillStyle = `rgba(255, 255, 255, ${particle.opacity})`;
    ctx.beginPath();
    ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
    ctx.fill();
  }

  // ---- Storm effect (wind streaks) ----
  if (STORM_INTENSITY > 10) {
    const stormOpacity = (STORM_INTENSITY / 100) * 0.4;
    ctx.strokeStyle = `rgba(255, 255, 255, ${stormOpacity})`;
    ctx.lineWidth = 1;

    for (let i = 0; i < 20; i++) {
      const x = (Math.sin(Date.now() * 0.001 + i) * 50 + i * 70 - cameraX * 0.8) % (gameCanvas.width + 100);
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x + 100 * (wind + 0.5), gameCanvas.height);
      ctx.stroke();
      }
  }
}
  // Draw snowy forest background
function drawSnowForest(cameraX = 0) {
  // Sky gradient (winter colors)
  const skyGradient = ctx.createLinearGradient(0, 0, 0, gameCanvas.height);
  skyGradient.addColorStop(0, '#3a506b');
  skyGradient.addColorStop(0.6, '#2c3e50');
  skyGradient.addColorStop(1, '#1a2530');
  ctx.fillStyle = skyGradient;
  ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);

  // Distant mountains (parallax)
  ctx.fillStyle = 'rgba(52, 73, 94, 0.8)';
  ctx.beginPath();
  ctx.moveTo(0 - cameraX * 0.2, gameCanvas.height);
  for (let i = 0; i < 20; i++) {
    const x = i * 150 - cameraX * 0.2;
    const h = 100 + Math.sin(i * 0.7) * 60;
    ctx.lineTo(x, gameCanvas.height - h);
  }
  ctx.lineTo(gameCanvas.width, gameCanvas.height);
  ctx.fill();

  // Snow caps on mountains
  ctx.fillStyle = 'rgba(236, 240, 241, 0.8)';
  ctx.beginPath();
  ctx.moveTo(0 - cameraX * 0.2, gameCanvas.height - 80);
  for (let i = 0; i < 20; i++) {
    const x = i * 150 - cameraX * 0.2;
    const h = 20 + Math.sin(i) * 10;
    ctx.lineTo(x, gameCanvas.height - 100 - h);
  }
  ctx.lineTo(gameCanvas.width, gameCanvas.height - 80);
  ctx.lineTo(gameCanvas.width, gameCanvas.height);
  ctx.lineTo(0, gameCanvas.height);
  ctx.fill();

  // Snowy trees with parallax
  const treeTypes = [
    // Pine trees with snow
    { draw: (x, y) => {
      // Trunk
      ctx.fillStyle = '#5d4037';
      ctx.fillRect(x - 5, y, 10, 60);
      
      // Snow layers
      ctx.fillStyle = '#e0e0e0';
      for (let j = 0; j < 3; j++) {
        const layerY = y - j * 25;
        const width = 40 - j * 10;
        const height = 30 - j * 5;
        
        ctx.beginPath();
        ctx.moveTo(x, layerY - height);
        ctx.lineTo(x - width, layerY);
        ctx.lineTo(x + width, layerY);
        ctx.closePath();
        ctx.fill();
        
        // Snow on top
        ctx.fillStyle = '#f5f5f5';
        ctx.beginPath();
        ctx.ellipse(x, layerY - height, width * 0.7, 10, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#e0e0e0';
      }
    }},
    
    // Snowy deciduous trees
    { draw: (x, y) => {
      // Trunk
      ctx.fillStyle = '#6d4c41';
      ctx.fillRect(x - 4, y, 8, 50);
      
      // Snow-covered canopy
      ctx.fillStyle = '#bbdefb';
      ctx.beginPath();
      ctx.arc(x, y - 30, 35, 0, Math.PI * 2);
      ctx.fill();
      
      // Snow cap
      ctx.fillStyle = '#f5f5f5';
      ctx.beginPath();
      ctx.ellipse(x, y - 50, 25, 15, 0, 0, Math.PI * 2);
      ctx.fill();
    }}
  ];

  // Draw trees with parallax
  for (let i = 0; i < 12; i++) {
    const treeType = treeTypes[i % treeTypes.length];
    const x = i * 200 - cameraX * 0.7;
    if (x > -100 && x < gameCanvas.width + 100) {
      treeType.draw(x, gameCanvas.height - 50);
    }
  }

  // Foreground snow mounds
  ctx.fillStyle = 'rgba(236, 240, 241, 0.9)';
  for (let i = 0; i < 15; i++) {
    const x = (i * 120 - cameraX * 0.9) % (gameCanvas.width + 200);
    const height = 20 + Math.sin(i) * 10;
    
    ctx.beginPath();
    ctx.arc(x, gameCanvas.height, 40, Math.PI, 0);
    ctx.lineTo(x + 40, gameCanvas.height);
    ctx.fill();
  }

  // Snow particles
  const intensity = SNOW_FOREST_SNOW_INTENSITY / 100;
  const wind = (SNOW_FOREST_WIND_INTENSITY - 50) / 50 * 1.5;
  
  for (let i = 0; i < 120 * intensity; i++) {
    const x = (i * 25 + (cameraX * 0.3)) % (gameCanvas.width + 100);
    const y = (gameCanvas.height - (Date.now() * 0.08 + i * 15) % (gameCanvas.height + 100));
    const size = 1.5 + Math.sin(Date.now() * 0.001 + i) * 1;
    
    ctx.fillStyle = `rgba(255, 255, 255, ${0.6 + Math.sin(Date.now() * 0.002 + i) * 0.2})`;
    ctx.beginPath();
    ctx.arc(x + wind * 20, y, size, 0, Math.PI * 2);
    ctx.fill();
  }

  // Gentle wind effect
  if (SNOW_FOREST_INTENSITY > 10) {
    const stormOpacity = (SNOW_FOREST_INTENSITY / 100) * 0.3;
    ctx.strokeStyle = `rgba(255, 255, 255, ${stormOpacity})`;
    ctx.lineWidth = 1;

    for (let i = 0; i < 15; i++) {
      const x = (Math.sin(Date.now() * 0.001 + i) * 30 + i * 80 - cameraX * 0.6) % (gameCanvas.width + 100);
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x + 70 * (wind + 0.5), gameCanvas.height);
      ctx.stroke();
    }
  }
}

function drawTempleRuinsBackground(cameraX) {
  const w = gameCanvas.width;
  const h = gameCanvas.height;
  const t = Date.now() * 0.001;
  const horizonY = Math.floor(h * 0.60);

  // ---------- LAYER 0: Jungle canopy sky + shafts of light ----------
  const sky = ctx.createLinearGradient(0, 0, 0, h);
  sky.addColorStop(0, '#0b1a16');  // deep jungle
  sky.addColorStop(0.45, '#10251f');
  sky.addColorStop(1, '#142c24');
  ctx.fillStyle = sky;
  ctx.fillRect(0, 0, w, h);

  // Sun shafts filtering through canopy
  for (let i = 0; i < 5; i++) {
    const x = (i * 220 + 80) - cameraX * 0.1;
    trLightShaft(x, 0, horizonY + 40, 80 + Math.sin(t * 0.6 + i) * 12, 0.06);
  }

  // ---------- LAYER 1: Distant temple silhouettes (parallax 0.25) ----------
  ctx.fillStyle = '#1b2f2a';
  for (let i = 0; i < 8; i++) {
    const bx = i * 260 - cameraX * 0.25;
    const base = horizonY - 70;
    const wstep = 130;
    const hstep = 18 + (i % 3) * 4;
    // stepped pyramid silhouette
    ctx.beginPath();
    ctx.moveTo(bx - wstep * 0.7, base);
    ctx.lineTo(bx + wstep * 0.7, base);
    ctx.lineTo(bx + wstep * 0.55, base - hstep * 1);
    ctx.lineTo(bx - wstep * 0.55, base - hstep * 1);
    ctx.lineTo(bx - wstep * 0.40, base - hstep * 2);
    ctx.lineTo(bx + wstep * 0.40, base - hstep * 2);
    ctx.lineTo(bx + wstep * 0.22, base - hstep * 3);
    ctx.lineTo(bx - wstep * 0.22, base - hstep * 3);
    ctx.lineTo(bx - 0, base - hstep * 4);
    ctx.lineTo(bx + 0, base - hstep * 4);
    ctx.closePath();
    ctx.fill();
  }

  // Thin morning mist behind ruins
  ctx.globalAlpha = 0.12;
  ctx.fillStyle = '#b9e6d7';
  for (let i = 0; i < 8; i++) {
    const fx = (i * 240 - cameraX * 0.2 + Math.sin(t * 0.7 + i) * 40) % (w + 480) - 120;
    ctx.beginPath();
    ctx.ellipse(fx, horizonY - 30 + Math.sin(i) * 6, 180, 26, 0, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;

  // ---------- LAYER 2: Midground temple walls/arches (parallax 0.45) ----------
  for (let i = 0; i < 6; i++) {
    const gx = i * 300 - cameraX * 0.45;
    const gy = horizonY + 4;

    // broken wall blocks
    trBlock(gx - 40, gy - 90, 90, 24, i * 11);
    trBlock(gx - 12, gy - 66, 120, 24, i * 17);
    trBlock(gx + 18, gy - 42, 140, 24, i * 23);

    // overgrown arch
    trArch(gx + 160, gy - 48, 1.0 + (i % 2) * 0.1, i * 31);

    // hanging vines over blocks/arch
    trVine(gx + 10, gy - 100, 90, t, 0.7);
    trVine(gx + 165, gy - 112, 110, t + 0.5, 1.0);
    trVine(gx + 210, gy - 108, 70, t + 1.1, 0.8);
  }

  // ---------- LAYER 3: Foreground rubble, roots, big leaves (parallax 0.8) ----------
  // ground gradient
  const ground = ctx.createLinearGradient(0, horizonY, 0, h);
  ground.addColorStop(0, '#1a2a24');
  ground.addColorStop(1, '#0e1b16');
  ctx.fillStyle = ground;
  ctx.fillRect(0, horizonY, w, h - horizonY);

  // creeping roots & rubble piles
  for (let i = 0; i < 7; i++) {
    const rx = (i * 220 - cameraX * 0.8) % (w + 440) - 120;
    if (rx < -140 || rx > w + 140) continue;

    trRoot(rx - 20, h - 18, 70 + (i % 3) * 12, t + i);
    trRubble(rx + 24, h - 16, 1.0 + (i % 2) * 0.15);

    // Big jungle leaves
    trLeafFan(rx - 10, h - 24, 22, 5, -0.3);
    trLeafFan(rx + 46, h - 20, 26, 6, 0.2);
  }

  // ---------- LAYER 4: Fireflies & drifting spores ----------
  for (let i = 0; i < 18; i++) {
    const fx = ((i * 120) - cameraX * 0.55 + Math.sin(t * 1.6 + i) * 25) % (w + 240) - 40;
    const fy = horizonY - 20 + (i % 5) * 16 + Math.sin(t * 2.1 + i * 0.8) * 8;
    trFirefly(fx, fy);
  }
}
function trLightShaft(x, topY, height, width, alpha = 0.06) {
  const g = ctx.createLinearGradient(x, topY, x, topY + height);
  g.addColorStop(0, `rgba(230,255,240,${alpha})`);
  g.addColorStop(1, 'rgba(230,255,240,0)');
  ctx.fillStyle = g;
  ctx.beginPath();
  ctx.moveTo(x - width * 0.5, topY);
  ctx.lineTo(x + width * 0.5, topY);
  ctx.lineTo(x + width, topY + height);
  ctx.lineTo(x - width, topY + height);
  ctx.closePath();
  ctx.fill();
}

function trBlock(x, y, w, h, seed = 0) {
  // stone body with slight bevel/variation
  const g = ctx.createLinearGradient(x, y - h, x, y + h);
  g.addColorStop(0, '#3a4b44');
  g.addColorStop(1, '#2b3a34');
  ctx.fillStyle = g;
  ctx.fillRect(x, y - h, w, h);

  // cracks
  ctx.strokeStyle = 'rgba(20,20,20,0.35)';
  ctx.lineWidth = 1;
  for (let i = 0; i < 3; i++) {
    const cx = x + (w * (0.2 + ((seed + i) % 7) / 10)) % (x + w);
    ctx.beginPath();
    ctx.moveTo(cx, y - h + 4 + (i * 6));
    ctx.quadraticCurveTo(cx + 6, y - h + 12 + i * 8, cx - 8, y - 4 + i * 5);
    ctx.stroke();
  }

  // moss overlay
  ctx.fillStyle = 'rgba(46, 109, 80, 0.35)';
  ctx.beginPath();
  ctx.moveTo(x - 2, y - h + 2);
  ctx.lineTo(x + w + 2, y - h + 2);
  ctx.lineTo(x + w - 10, y - h + 10);
  ctx.lineTo(x + 8, y - h + 12);
  ctx.closePath();
  ctx.fill();
}

function trArch(cx, cy, s = 1, seed = 0) {
  // two pillars
  ctx.fillStyle = '#34483f';
  ctx.fillRect(cx - 64 * s, cy - 50 * s, 18 * s, 60 * s);
  ctx.fillRect(cx + 46 * s, cy - 50 * s, 18 * s, 60 * s);

  // curved lintel (semi-circle)
  ctx.beginPath();
  ctx.arc(cx, cy - 52 * s, 56 * s, Math.PI, 0);
  ctx.lineTo(cx + 56 * s, cy - 40 * s);
  ctx.lineTo(cx - 56 * s, cy - 40 * s);
  ctx.closePath();
  ctx.fill();

  // chips/missing stones
  ctx.save();
  ctx.globalCompositeOperation = 'destination-out';
  ctx.fillStyle = 'rgba(0,0,0,0.8)';
  for (let i = 0; i < 4; i++) {
    ctx.beginPath();
    ctx.ellipse(cx + (i * 12 - 22) * s, cy - 46 * s + (i % 2) * 6 * s, 4 * s, 3 * s, 0, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.restore();

  // vine draping across the arch
  trVine(cx - 60 * s, cy - 58 * s, 140 * s, Date.now() * 0.001 + seed, 0.9);
}

function trVine(x, y, len, t, drift = 1.0) {
  ctx.strokeStyle = 'rgba(60,140,100,0.85)';
  ctx.lineWidth = 3;
  const sway = Math.sin(t * 1.2) * 12 * drift;
  ctx.beginPath();
  ctx.moveTo(x, y);
  ctx.bezierCurveTo(x + sway * 0.3, y + len * 0.33,
                    x - sway * 0.2, y + len * 0.66,
                    x + sway * 0.5, y + len);
  ctx.stroke();

  // small leaf clusters hanging from the vine
  for (let i = 0; i < 4; i++) {
    const ly = y + (i + 1) * (len / 5);
    trLeafCluster(x + Math.sin(t + i) * 8, ly, 6 + (i % 2) * 2);
  }
}

function trLeafCluster(x, y, r = 6) {
  ctx.fillStyle = 'rgba(50,160,110,0.95)';
  for (let i = 0; i < 5; i++) {
    const ang = i * (Math.PI * 2 / 5);
    ctx.beginPath();
    ctx.ellipse(x + Math.cos(ang) * (r * 0.6), y + Math.sin(ang) * (r * 0.4), r, r * 0.55, ang, 0, Math.PI * 2);
    ctx.fill();
  }
}

function trLeafFan(x, y, radius = 24, count = 5, rot = 0) {
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(rot);
  for (let i = 0; i < count; i++) {
    const ang = -Math.PI / 2 + (i - (count - 1) / 2) * 0.28;
    ctx.fillStyle = 'rgba(40,150,100,0.95)';
    ctx.beginPath();
    ctx.ellipse(Math.cos(ang) * radius * 0.4, Math.sin(ang) * radius * 0.15, radius, radius * 0.4, ang, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.restore();
}

function trRoot(x, baseY, len, t = 0) {
  ctx.strokeStyle = 'rgba(75,55,35,0.9)';
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.moveTo(x, baseY);
  ctx.bezierCurveTo(x + 20, baseY - 8, x + 30, baseY - 14, x + 40, baseY - 10);
  ctx.bezierCurveTo(x + 46, baseY - 6, x + len, baseY - 4 + Math.sin(t) * 2, x + len + 12, baseY - 2);
  ctx.stroke();
}

function trRubble(x, baseY, s = 1) {
  // shadow
  ctx.save();
  ctx.globalAlpha = 0.35;
  ctx.fillStyle = '#000';
  ctx.beginPath();
  ctx.ellipse(x + 10 * s, baseY + 3 * s, 40 * s, 10 * s, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();

  // stones
  ctx.fillStyle = '#31463d';
  ctx.beginPath();
  ctx.moveTo(x - 34 * s, baseY);
  ctx.lineTo(x - 8 * s, baseY - 14 * s);
  ctx.lineTo(x + 6 * s, baseY - 6 * s);
  ctx.lineTo(x + 22 * s, baseY - 18 * s);
  ctx.lineTo(x + 40 * s, baseY - 6 * s);
  ctx.lineTo(x + 52 * s, baseY);
  ctx.closePath();
  ctx.fill();

  // moss dots
  ctx.fillStyle = 'rgba(46,109,80,0.45)';
  for (let i = 0; i < 6; i++) {
    ctx.beginPath();
    ctx.arc(x - 22 * s + i * 14 * s, baseY - 6 * s - (i % 2) * 4 * s, 2.2, 0, Math.PI * 2);
    ctx.fill();
  }
}

function trFirefly(x, y) {
  const g = ctx.createRadialGradient(x, y, 0, x, y, 9);
  g.addColorStop(0, 'rgba(220,255,180,0.95)');
  g.addColorStop(1, 'rgba(220,255,180,0)');
  ctx.fillStyle = g;
  ctx.beginPath();
  ctx.arc(x, y, 9, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle = 'rgba(255,255,230,0.9)';
  ctx.beginPath();
  ctx.arc(x, y, 2, 0, Math.PI * 2);
  ctx.fill();
}


function drawHauntedSwampBackground(cameraX) {
  const w = gameCanvas.width;
  const h = gameCanvas.height;
  const t = Date.now() * 0.001;

  // ---------- LAYER 0: Night sky + moon ----------
  const sky = ctx.createLinearGradient(0, 0, 0, h);
  sky.addColorStop(0, '#04070b');
  sky.addColorStop(0.5, '#090f15');
  sky.addColorStop(1, '#0a1216');
  ctx.fillStyle = sky;
  ctx.fillRect(0, 0, w, h);

  // Pale moon behind fog
  const moonX = 120 - cameraX * 0.05;
  const moonY = 70;
  const mg = ctx.createRadialGradient(moonX, moonY, 0, moonX, moonY, 40);
  mg.addColorStop(0, 'rgba(230,240,255,0.9)');
  mg.addColorStop(1, 'rgba(230,240,255,0)');
  ctx.fillStyle = mg;
  ctx.beginPath();
  ctx.arc(moonX, moonY, 40, 0, Math.PI * 2);
  ctx.fill();

  // High thin fog band
  swampFogBand(h * 0.25, 0.18, 0.25, 0.25, cameraX, t);
  swampFogBand(h * 0.35, 0.15, 0.2,  0.2,  cameraX, t);

  // ---------- LAYER 1: Distant trees (silhouettes) ----------
  const horizonY = Math.floor(h * 0.55);
  ctx.strokeStyle = 'rgba(20,40,35,0.8)';
  for (let i = 0; i < 9; i++) {
    const x = i * 200 - cameraX * 0.25;
    drawLeaflessTree(x, horizonY + 8, 120 + (i % 3) * 14, -0.06 + 0.02 * Math.sin(i));
  }

  // ---------- LAYER 2: Murky water / mud ----------
  const water = ctx.createLinearGradient(0, horizonY, 0, h);
  water.addColorStop(0, '#0b1e1e'); // surface
  water.addColorStop(1, '#081312'); // deep mud
  ctx.fillStyle = water;
  ctx.fillRect(0, horizonY, w, h - horizonY);

  // Mud bars / banks
  ctx.fillStyle = 'rgba(20,35,30,0.8)';
  ctx.beginPath();
  ctx.moveTo(-cameraX * 0.35, horizonY + 18);
  for (let i = 0; i <= 12; i++) {
    const x = i * (w / 12) - cameraX * 0.35;
    const y = horizonY + 16 + Math.sin(i * 0.8 + t * 0.7) * 3;
    ctx.lineTo(x, y);
  }
  ctx.lineTo(w, h);
  ctx.lineTo(0, h);
  ctx.closePath();
  ctx.fill();

  // ---------- LAYER 3: Bone clusters half-buried ----------
  for (let i = 0; i < 7; i++) {
    const bx = (i * 220 - cameraX * 0.55 + 60 * Math.sin(i * 1.7)) % (w + 440) - 120;
    if (bx < -130 || bx > w + 130) continue;
    const by = horizonY + 24 + ((i % 3) * 6);
    drawBoneCluster(bx, by, 0.9 + (i % 2) * 0.15);
  }

  // ---------- LAYER 4: Closer trees + hanging moss ----------
  ctx.strokeStyle = 'rgba(35,65,55,0.9)';
  for (let i = 0; i < 7; i++) {
    const x = i * 260 - cameraX * 0.6;
    drawLeaflessTree(x, horizonY + 12, 150 + (i % 3) * 20, 0.08 * Math.sin(t + i));
    // hanging moss on foreground trees
    drawHangingMoss(x, horizonY + 12, 150 + (i % 3) * 20, t);
  }

  // ---------- LAYER 5: Ground fog + will-o'-wisps ----------
  swampFogBand(horizonY + 10, 0.22, 0.35, 0.45, cameraX, t);
  swampFogBand(horizonY + 40, 0.16, 0.45, 0.55, cameraX, t);

  for (let i = 0; i < 10; i++) {
    const fx = ((i * 140) - cameraX * 0.5 + Math.sin(t * 1.7 + i) * 20) % (w + 280) - 40;
    const fy = horizonY - 10 + (i % 4) * 16 + Math.sin(t * 2 + i) * 6;
    if (fx > -40 && fx < w + 40) swampWisp(fx, fy);
  }
}

/* ================= Helpers (swamp*) ================= */

function drawLeaflessTree(x, baseY, height, bend = 0) {
  // trunk
  ctx.save();
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(x, baseY);
  ctx.bezierCurveTo(
    x + bend * 40, baseY - height * 0.35,
    x + bend * 30, baseY - height * 0.75,
    x + bend * 10, baseY - height
  );
  ctx.stroke();

  // branches
  const branchCount = 7;
  for (let i = 0; i < branchCount; i++) {
    const t = i / (branchCount - 1);
    const y = baseY - height * (0.2 + t * 0.75);
    const baseX = x + bend * 15 * (0.2 + t);
    const len = 24 + 34 * (1 - t);
    const spread = 0.9 - 0.4 * t;

    // left branch
    ctx.beginPath();
    ctx.moveTo(baseX, y);
    ctx.quadraticCurveTo(
      baseX - len * spread * 0.6, y - len * 0.3,
      baseX - len, y - len * 0.55
    );
    ctx.stroke();

    // right branch
    ctx.beginPath();
    ctx.moveTo(baseX, y);
    ctx.quadraticCurveTo(
      baseX + len * spread * 0.6, y - len * 0.25,
      baseX + len * 0.9, y - len * 0.5
    );
    ctx.stroke();

    // small sub-branch tips (claws)
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(baseX - len, y - len * 0.55);
    ctx.lineTo(baseX - len - 8, y - len * 0.55 - 6);
    ctx.moveTo(baseX + len * 0.9, y - len * 0.5);
    ctx.lineTo(baseX + len * 0.9 + 8, y - len * 0.5 - 6);
    ctx.stroke();
    ctx.lineWidth = 3;
  }
  ctx.restore();
}

function drawHangingMoss(x, baseY, height, t) {
  ctx.save();
  ctx.strokeStyle = 'rgba(60,120,90,0.25)';
  ctx.lineWidth = 2;

  // hang a few strands from upper trunk line
  for (let i = 0; i < 6; i++) {
    const yy = baseY - height * (0.55 + i * 0.06);
    const xx = x + (i - 2.5) * 10;
    const sway = Math.sin(t * 1.3 + i) * 6;
    ctx.beginPath();
    ctx.moveTo(xx, yy);
    ctx.quadraticCurveTo(xx + sway * 0.5, yy + 12, xx + sway, yy + 28 + (i % 3) * 10);
    ctx.stroke();
  }
  ctx.restore();
}

function drawBoneCluster(x, y, s = 1) {
  // muddy shadow
  ctx.save();
  ctx.globalAlpha = 0.4;
  ctx.fillStyle = '#000';
  ctx.beginPath();
  ctx.ellipse(x, y + 4 * s, 18 * s, 8 * s, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();

  // skull
  ctx.fillStyle = 'rgba(230,230,230,0.9)';
  ctx.strokeStyle = 'rgba(40,40,40,0.7)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.ellipse(x - 6 * s, y - 6 * s, 9 * s, 7 * s, 0, 0, Math.PI * 2);
  ctx.fill(); ctx.stroke();

  // sockets
  ctx.fillStyle = 'rgba(20,20,20,0.8)';
  ctx.beginPath();
  ctx.ellipse(x - 9 * s, y - 6 * s, 2.2 * s, 3 * s, 0, 0, Math.PI * 2);
  ctx.ellipse(x - 3 * s, y - 6 * s, 2.2 * s, 3 * s, 0, 0, Math.PI * 2);
  ctx.fill();

  // jaw hint
  ctx.strokeStyle = 'rgba(60,60,60,0.7)';
  ctx.beginPath();
  ctx.moveTo(x - 11 * s, y - 1 * s);
  ctx.quadraticCurveTo(x - 6 * s, y + 2 * s, x - 1 * s, y - 1 * s);
  ctx.stroke();

  // ribs (two arcing bones)
  ctx.strokeStyle = 'rgba(220,220,220,0.85)';
  ctx.lineWidth = 2;
  for (let i = 0; i < 3; i++) {
    ctx.beginPath();
    ctx.arc(x + 8 * s, y + (i - 1) * 4 * s, 10 * s, Math.PI * 0.1, Math.PI * 0.95);
    ctx.stroke();
  }

  // femur-like bone
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(x + 18 * s, y + 2 * s);
  ctx.lineTo(x + 30 * s, y - 4 * s);
  ctx.stroke();
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.arc(x + 30 * s, y - 4 * s, 3 * s, 0, Math.PI * 2);
  ctx.stroke();
}

function swampFogBand(y, alpha, parallax, speed, cameraX, t) {
  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.fillStyle = '#9fc7bd';
  for (let i = 0; i < 8; i++) {
    const cx = (i * 220 - cameraX * parallax + Math.sin(t * (12 * speed) + i) * 40) % (gameCanvas.width + 440) - 120;
    const cy = y + Math.sin(t * 0.8 + i) * 6;
    ctx.beginPath();
    ctx.ellipse(cx, cy, 160, 26, 0, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.restore();
}

function swampWisp(x, y) {
  const g = ctx.createRadialGradient(x, y, 0, x, y, 10);
  g.addColorStop(0, 'rgba(170,230,255,0.95)');
  g.addColorStop(1, 'rgba(170,230,255,0)');
  ctx.fillStyle = g;
  ctx.beginPath();
  ctx.arc(x, y, 10, 0, Math.PI * 2);
  ctx.fill();

  // tiny core
  ctx.fillStyle = 'rgba(255,255,255,0.9)';
  ctx.beginPath();
  ctx.arc(x, y, 2.5, 0, Math.PI * 2);
  ctx.fill();
}


function drawPondBackground(cameraX) {
  const w = gameCanvas.width;
  const h = gameCanvas.height;
  const t = Date.now() * 0.001;

  // ---------- LAYER 0: Sky + distant bank ----------
  // Twilight sky
  let sky = ctx.createLinearGradient(0, 0, 0, h * 0.38);
  sky.addColorStop(0, '#0a1c28');     // deep blue
  sky.addColorStop(1, '#123247');     // teal dusk
  ctx.fillStyle = sky;
  ctx.fillRect(0, 0, w, h * 0.38);

  // Far bank silhouette
  const horizonY = Math.floor(h * 0.36);
  ctx.fillStyle = '#0a2430';
  ctx.beginPath();
  ctx.moveTo(-cameraX * 0.2, horizonY);
  for (let i = 0; i <= 12; i++) {
    const x = i * (w / 12) - cameraX * 0.2;
    const y = horizonY - 6 - Math.sin(i * 0.8 + t * 0.3) * 4;
    ctx.lineTo(x, y);
  }
  ctx.lineTo(w, horizonY + 40);
  ctx.lineTo(0, horizonY + 40);
  ctx.closePath();
  ctx.fill();

  // Subtle fireflies on the bank
  for (let i = 0; i < 18; i++) {
    const fx = ((i * 120) - cameraX * 0.15) % (w + 240);
    const fy = horizonY - 20 + (i % 3) * -10 + Math.sin(t * 1.8 + i) * 6;
    if (fx >= -40 && fx <= w + 40) {
      pondGlowDot(fx, fy, 6, 'rgba(220,255,180,0.7)');
      pondGlowDot(fx, fy, 2, 'rgba(255,255,230,0.9)');
    }
  }

  // ---------- LAYER 1: Water body ----------

// Main water gradient
let water = ctx.createLinearGradient(0, horizonY, 0, h);
water.addColorStop(0, '#0e3a4a');  // surface teal
water.addColorStop(1, '#05161d');  // deep blue
ctx.fillStyle = water;
ctx.fillRect(0, horizonY, w, h - horizonY);

// Surface sheen / ripples ‚Äî top half of water only (no clip)
const rippleMaxY = horizonY + (h - horizonY) * 0.5; // only draw above this
ctx.lineWidth = 1;
for (let i = 0; i < 16; i++) {
  const y = horizonY + 10 + i * 10 + Math.sin(t * 0.8 + i * 0.6) * 2;
  if (y > rippleMaxY) continue; // skip bottom half

  // Fade strength with depth (0 at top -> 1 at bottom of ripple band)
  const depth01 = (y - horizonY) / (rippleMaxY - horizonY);
  const alpha   = 0.12 * (1 - depth01);
  ctx.strokeStyle = `rgba(255,255,255,${alpha})`;

  ctx.beginPath();
  ctx.moveTo(0, y);
  for (let x = 0; x <= w; x += 40) {
    const yy = y + Math.sin((x + t * 80) * 0.02 + i) * 0.8 * (1 - depth01);
    ctx.lineTo(x, yy);
  }
  ctx.stroke();
}

// Soft caustics in a shallow band near the surface
ctx.globalAlpha = 0.06;
ctx.strokeStyle = '#c8ffff';
const causticMaxY = horizonY + (h - horizonY) * 0.45; // even shallower than ripples
for (let k = 0; k < 12; k++) {
  const y = horizonY + 40 + k * 14;
  if (y > causticMaxY) break;
  ctx.beginPath();
  for (let x = -20; x <= w + 20; x += 24) {
    const yy = y + Math.sin(0.06 * x + t * 1.4 + k) * 3;
    ctx.lineTo(x, yy);
  }
  ctx.stroke();
}
ctx.globalAlpha = 1;


  // ---------- LAYER 2: Tadpole homes (underwater, parallax slow) ----------
  // Pond floor contour (subtle)
  ctx.fillStyle = '#082128';
  ctx.beginPath();
  ctx.moveTo(-cameraX * 0.25, h - 32);
  for (let i = 0; i <= 10; i++) {
    const x = i * (w / 10) - cameraX * 0.25;
    const y = h - 30 - Math.sin(i * 0.9 + t * 0.6) * 6;
    ctx.lineTo(x, y);
  }
  ctx.lineTo(w, h);
  ctx.lineTo(0, h);
  ctx.closePath();
  ctx.fill();

  // Colorful houses dotted along the pond bed
  const houseCount = 8;
  for (let i = 0; i < houseCount; i++) {
    const baseX = (i * 260 - cameraX * 0.35) % (w + 520) - 100;
    if (baseX < -140 || baseX > w + 140) continue;
    const baseY = h - 38 - Math.sin(i * 0.7 + t * 0.3) * 4;
    const scale = 0.75 + ((i % 3) * 0.15);
    const hue = (i * 47) % 360;  // colorful!
    pondHouse(baseX, baseY, scale, hue);

    // Bubble trail from chimney
    for (let b = 0; b < 5; b++) {
      const bob = t * (0.7 + i * 0.03);
      const bx = baseX + 18 * scale + Math.sin(bob * 2 + b) * 3;
      const by = baseY - 24 * scale - ( ( (t * 40 + i * 13 + b * 18) % 120) );
      if (by > horizonY + 8 && by < h - 10) {
        pondBubble(bx, by, 2 + (b % 2), 0.35 + (b * 0.08));
      }
    }

    // Little garden kelp around houses
    pondKelpCluster(baseX - 28 * scale, h - 32, 40 * scale, i * 1.1 + t);
    pondKelpCluster(baseX + 42 * scale, h - 32, 48 * scale, i * 1.7 + t * 1.1);
  }

  // ---------- LAYER 3: Surface props (pads + lotus drawn last) ----------
const PAD_COUNT = 14;
const pads = [];

// Build pad list first (so we can sort & multi-pass)
for (let i = 0; i < PAD_COUNT; i++) {
  const padX = (i * 160 - cameraX * 0.55 + Math.sin(t + i) * 12) % (w + 320) - 80;
  if (padX < -120 || padX > w + 120) { pads.push(null); continue; }

  const padY = horizonY + 28 + (i % 4) * 16 + Math.sin(t * 0.6 + i) * 3;
  const rx = 36 + (i % 3) * 8;              // width
  const ry = Math.max(14, rx * 0.42);       // flat height
  const hasLotus = (i % 3 === 0);           // same rule as before

  pads.push({ x: padX, y: padY, rx, ry, hasLotus });
}

// Optional: depth-sort pads so overlaps look natural
pads.sort((a, b) => {
  if (!a) return -1; if (!b) return 1;
  return a.y - b.y;  // shallower (higher y) behind deeper (lower y)
});

// Pass 1 ‚Äî draw all pads + their ripples
for (const p of pads) {
  if (!p) continue;
  pondLilyPad(p.x, p.y, p.rx, p.ry);
  pondPadRipples(p.x, p.y, p.rx, p.ry, t);
}

// Pass 2 ‚Äî draw ALL lotus on top (so pads never cover them)
for (const p of pads) {
  if (!p || !p.hasLotus) continue;
  pondLotus(p.x + 6, p.y - 6, 0.9); // small offset like before
}

  // ---------- LAYER 4: Foreground reeds & skimmers ----------
  for (let i = 0; i < 16; i++) {
    const rx = (i * 120 - cameraX * 0.85) % (w + 240) - 60;
    if (rx < -80 || rx > w + 80) continue;
    const sway = Math.sin(t * 1.4 + i) * 6;
    pondReed(rx, h - 20, 90 + (i % 5) * 12, sway);
  }

  // Dragonfly skimmers
  for (let i = 0; i < 6; i++) {
    const dx = ((i * 260) - cameraX * 0.6 + Math.sin(t * 2 + i) * 40) % (w + 520) - 60;
    const dy = horizonY + 20 + Math.sin(t * 2.4 + i * 1.7) * 12;
    if (dx >= -40 && dx <= w + 40) {
      pondDragonfly(dx, dy);
    }
  }
}

/* ----------------- Helpers (scoped to pond) ----------------- */

function pondGlowDot(x, y, r, color) {
  const g = ctx.createRadialGradient(x, y, 0, x, y, r);
  g.addColorStop(0, color);
  g.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = g;
  ctx.beginPath();
  ctx.arc(x, y, r, 0, Math.PI * 2);
  ctx.fill();
}

function pondBubble(x, y, r, alpha = 0.4) {
  const g = ctx.createRadialGradient(x, y, 0, x, y, r + 2);
  g.addColorStop(0, `rgba(255,255,255,${alpha})`);
  g.addColorStop(1, 'rgba(255,255,255,0)');
  ctx.fillStyle = g;
  ctx.beginPath();
  ctx.arc(x, y, r + 2, 0, Math.PI * 2);
  ctx.fill();

  // thin rim
  ctx.strokeStyle = `rgba(255,255,255,${Math.min(0.8, alpha + 0.2)})`;
  ctx.lineWidth = 0.5;
  ctx.beginPath();
  ctx.arc(x, y, r, 0, Math.PI * 2);
  ctx.stroke();
}

function pondHouse(x, y, s, hue = 190) {
  // Base (stone)
  ctx.fillStyle = 'rgba(40,60,70,0.8)';
  ctx.beginPath();
  ctx.ellipse(x, y, 34 * s, 10 * s, 0, 0, Math.PI * 2);
  ctx.fill();

  // Walls
  ctx.fillStyle = `hsl(${hue}, 60%, 52%)`;
  ctx.beginPath();
  ctx.roundRect?.(x - 30 * s, y - 30 * s, 60 * s, 32 * s, 6 * s);
  if (!ctx.roundRect) {
    // fallback if roundRect not supported
    ctx.rect(x - 30 * s, y - 30 * s, 60 * s, 32 * s);
  }
  ctx.fill();

  // Dome roof
  const roofGrad = ctx.createLinearGradient(x, y - 55 * s, x, y - 15 * s);
  roofGrad.addColorStop(0, `hsl(${(hue + 30) % 360}, 70%, 70%)`);
  roofGrad.addColorStop(1, `hsl(${(hue + 10) % 360}, 70%, 55%)`);
  ctx.fillStyle = roofGrad;
  ctx.beginPath();
  ctx.ellipse(x, y - 30 * s, 38 * s, 20 * s, 0, Math.PI, 0);
  ctx.closePath();
  ctx.fill();

  // Door
  ctx.fillStyle = 'rgba(20,30,40,0.9)';
  ctx.beginPath();
  ctx.moveTo(x - 8 * s, y + 2 * s);
  ctx.lineTo(x + 8 * s, y + 2 * s);
  ctx.quadraticCurveTo(x + 8 * s, y - 10 * s, x, y - 16 * s);
  ctx.quadraticCurveTo(x - 8 * s, y - 10 * s, x - 8 * s, y + 2 * s);
  ctx.closePath();
  ctx.fill();

  // Windows glow
  const winCols = [['#fff7b0', '#ffeb80'], ['#d9fff6', '#aef5ea']];
  for (let k = -1; k <= 1; k += 2) {
    const wx = x + k * 18 * s;
    const wy = y - 16 * s;
    const g = ctx.createRadialGradient(wx, wy, 0, wx, wy, 8 * s);
    const palette = winCols[(k + 1) / 2];
    g.addColorStop(0, `${palette[0]}AA`);
    g.addColorStop(1, `${palette[1]}00`);
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(wx, wy, 8 * s, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = 'rgba(255,255,220,0.8)';
    ctx.beginPath();
    ctx.arc(wx, wy, 4 * s, 0, Math.PI * 2);
    ctx.fill();
  }

  // Tiny chimney
  ctx.fillStyle = `hsl(${(hue + 10) % 360}, 40%, 35%)`;
  ctx.fillRect(x + 10 * s, y - 38 * s, 8 * s, 10 * s);
}

function pondKelpCluster(x, baseY, height, phase) {
  ctx.strokeStyle = 'rgba(60,200,160,0.35)';
  ctx.lineWidth = 2;
  for (let i = 0; i < 3; i++) {
    const off = i * 6;
    const sway = Math.sin(phase * 0.9 + i) * 10;
    ctx.beginPath();
    ctx.moveTo(x + off, baseY);
    ctx.bezierCurveTo(
      x + off + sway * 0.2, baseY - height * 0.33,
      x + off - sway * 0.4, baseY - height * 0.66,
      x + off + sway * 0.6, baseY - height
    );
    ctx.stroke();
  }
}

function pondLilyPad(x, y, rx, ry) {
  // Soft drop shadow directly on the water
  ctx.save();
  ctx.globalAlpha = 0.35;
  ctx.fillStyle = 'rgba(0,0,0,0.35)';
  ctx.beginPath();
  ctx.ellipse(x, y + 2, rx * 1.03, ry * 1.08, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();

  // Pad fill (vertical gradient to feel flat on the water)
  const grad = ctx.createLinearGradient(x, y - ry, x, y + ry);
  grad.addColorStop(0, 'rgba(70,160,100,0.98)'); // lighter top
  grad.addColorStop(1, 'rgba(30,95,60,0.98)');   // darker bottom
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.ellipse(x, y, rx, ry, 0, 0, Math.PI * 2);
  ctx.fill();

  // Rim highlight to sell the flat top edge
  ctx.strokeStyle = 'rgba(200,255,200,0.45)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.ellipse(x, y, rx, ry, 0, 0, Math.PI * 2);
  ctx.stroke();

  // Subtle specular highlight near the top edge
  ctx.strokeStyle = 'rgba(255,255,255,0.25)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.ellipse(x, y - 1, rx * 0.9, ry * 0.85, 0, Math.PI * 1.05, Math.PI * 1.95);
  ctx.stroke();
}

function pondLotus(x, y, s = 1) {
  // ---- helpers ----
  const drawPetal = (len, width, angle, topCol, baseCol, strokeA = 0.12) => {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(angle); // tip points along +angle
    const grad = ctx.createLinearGradient(0, 0, 0, -len);
    grad.addColorStop(0, baseCol);
    grad.addColorStop(0.55, topCol);
    grad.addColorStop(1, 'rgba(255,255,255,0.95)');
    ctx.fillStyle = grad;

    // teardrop/lotus petal
    ctx.beginPath();
    ctx.moveTo(0, 0);                                 // base
    ctx.bezierCurveTo(width * 0.95, -len * 0.35,      // right shoulder
                      width * 0.55, -len * 0.82,      // right taper
                      0, -len);                       // tip
    ctx.bezierCurveTo(-width * 0.55, -len * 0.82,     // left taper
                      -width * 0.95, -len * 0.35,     // left shoulder
                      0, 0);                          // back to base
    ctx.closePath();
    ctx.fill();

    // subtle rim
    ctx.strokeStyle = `rgba(255,255,255,${strokeA})`;
    ctx.lineWidth = Math.max(0.8 * s, 1);
    ctx.stroke();
    ctx.restore();
  };

  const drawSepal = (len, width, angle) => {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(angle);
    const g = ctx.createLinearGradient(0, 0, 0, -len);
    g.addColorStop(0, 'rgba(40,110,70,0.95)');
    g.addColorStop(1, 'rgba(90,170,110,0.95)');
    ctx.fillStyle = g;

    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.bezierCurveTo(width * 0.8, -len * 0.35, width * 0.45, -len * 0.8, 0, -len);
    ctx.bezierCurveTo(-width * 0.45, -len * 0.8, -width * 0.8, -len * 0.35, 0, 0);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  };

  // ---- water shadow (anchors to surface) ----
  ctx.save();
  ctx.globalAlpha = 0.18;
  ctx.fillStyle = '#000';
  ctx.beginPath();
  ctx.ellipse(x, y + 3 * s, 16 * s, 8 * s, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();

  // ---- green sepals underneath (5) ----
  const sepals = 5;
  for (let i = 0; i < sepals; i++) {
    const ang = (i / sepals) * Math.PI * 2 + Math.PI / sepals;
    drawSepal(16 * s, 7 * s, ang);
  }

  // ---- outer petal ring (12) ----
  const outerCount = 12;
  for (let i = 0; i < outerCount; i++) {
    const ang = (i / outerCount) * Math.PI * 2;
    // small organic variation
    const jitter = (Math.sin(i * 2.3) * 0.08);
    drawPetal(22 * s, 9 * s,
              ang + jitter,
              'rgba(255,240,246,0.98)',   // top/light
              'rgba(240,140,180,0.95)',   // base/pink
              0.10);
  }

  // ---- inner petal ring (8) ----
  const innerCount = 8;
  for (let i = 0; i < innerCount; i++) {
    const ang = (i / innerCount) * Math.PI * 2 + Math.PI / innerCount; // offset
    const jitter = (Math.cos(i * 1.7) * 0.06);
    drawPetal(17 * s, 7 * s,
              ang + jitter,
              'rgba(255,248,252,0.98)',
              'rgba(235,110,160,0.95)',
              0.12);
  }

  // ---- stamen ring (thin yellow filaments around center) ----
  ctx.save();
  ctx.translate(x, y);
  const stamens = 22;
  for (let i = 0; i < stamens; i++) {
    const ang = (i / stamens) * Math.PI * 2;
    ctx.save();
    ctx.rotate(ang);
    const len = 8 * s;
    ctx.strokeStyle = 'rgba(255,215,90,0.9)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(0, -5 * s);
    ctx.lineTo(0, -5 * s - len);
    ctx.stroke();
    // tiny pollen tip
    ctx.fillStyle = 'rgba(255,230,120,0.95)';
    ctx.beginPath();
    ctx.arc(0, -5 * s - len, 1.6 * s, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }
  ctx.restore();

  // ---- central seed pod (green disc with holes) ----
  const podR = 7 * s;
  const podGrad = ctx.createRadialGradient(x, y - 1 * s, 0, x, y, podR);
  podGrad.addColorStop(0, 'rgba(255,245,140,0.95)');
  podGrad.addColorStop(1, 'rgba(150,190,80,0.95)');
  ctx.fillStyle = podGrad;
  ctx.beginPath();
  ctx.arc(x, y, podR, 0, Math.PI * 2);
  ctx.fill();

  // holes on pod
  ctx.fillStyle = 'rgba(40,70,30,0.35)';
  const holeR = 1.2 * s;
  const holeRing = 6;
  for (let i = 0; i < holeRing; i++) {
    const ang = (i / holeRing) * Math.PI * 2;
    const hx = x + Math.cos(ang) * (podR * 0.55);
    const hy = y + Math.sin(ang) * (podR * 0.45);
    ctx.beginPath();
    ctx.arc(hx, hy, holeR, 0, Math.PI * 2);
    ctx.fill();
  }
  // center hole
  ctx.beginPath();
  ctx.arc(x, y, holeR, 0, Math.PI * 2);
  ctx.fill();

  // highlight glint on pod
  ctx.strokeStyle = 'rgba(255,255,255,0.55)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.arc(x - 2 * s, y - 2 * s, podR * 0.65, Math.PI * 1.2, Math.PI * 1.6);
  ctx.stroke();
}

function pondPadRipples(x, y, rx, ry, t) {
  ctx.save();
  ctx.strokeStyle = 'rgba(255,255,255,0.07)';
  ctx.lineWidth = 1;

  // Three faint rings that breathe over time
  for (let k = 1; k <= 3; k++) {
    const scale = 1 + k * 0.1;
    const wobble = Math.sin(t * (0.8 + k * 0.15)) * 0.6;
    ctx.beginPath();
    ctx.ellipse(x, y + wobble, rx * scale, ry * scale, 0, 0, Math.PI * 2);
    ctx.stroke();
  }
  ctx.restore();
}

function pondReed(x, baseY, height, sway = 0) {
  ctx.strokeStyle = 'rgba(70,180,130,0.6)';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(x, baseY);
  ctx.quadraticCurveTo(x + sway * 0.4, baseY - height * 0.5, x + sway, baseY - height);
  ctx.stroke();

  // Seed head
  ctx.fillStyle = 'rgba(150,120,80,0.8)';
  ctx.beginPath();
  ctx.ellipse(x + sway, baseY - height - 8, 4, 10, 0, 0, Math.PI * 2);
  ctx.fill();
}

function pondDragonfly(x, y) {
  // Body
  ctx.fillStyle = 'rgba(120,200,220,0.9)';
  ctx.fillRect(x - 2, y - 2, 4, 16);
  // Wings
  ctx.fillStyle = 'rgba(220,250,255,0.5)';
  ctx.beginPath();
  ctx.ellipse(x - 6, y, 10, 4, -0.4, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(x + 6, y, 10, 4, 0.4, 0, Math.PI * 2);
  ctx.fill();
  // Tiny glow
  pondGlowDot(x, y - 2, 4, 'rgba(180,240,255,0.5)');
}


  function drawBiolakeBackground(cameraX) {
  // Night water gradient (deep blue to dark teal)
  const waterGradient = ctx.createLinearGradient(0, 0, 0, gameCanvas.height);
  waterGradient.addColorStop(0, '#0a2a3a');  // Surface (very dark blue)
  waterGradient.addColorStop(1, '#051a1a');  // Depth (dark teal)
  ctx.fillStyle = waterGradient;
  ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);

  // Moon reflection (subtle light path)
  ctx.fillStyle = 'rgba(100, 150, 200, 0.1)';
  ctx.beginPath();
  ctx.moveTo(0, 0);
  for (let i = 0; i < 10; i++) {
    const x = i * 200 - cameraX * 0.1;
    const width = 100 + Math.sin(i) * 30;
    ctx.lineTo(x, 0);
    ctx.lineTo(x + width, gameCanvas.height);
  }
  ctx.lineTo(gameCanvas.width, gameCanvas.height);
  ctx.closePath();
  ctx.fill();

  // Glowing lily pads (platforms will go on top of these)
  for (let i = 0; i < 12; i++) {
    const x = (i * 250 + cameraX * 0.3) % (gameCanvas.width + 500);
    const y = gameCanvas.height - 50 + Math.sin(i * 0.5) * 10;
    
    // Outer glow
    const glowGradient = ctx.createRadialGradient(
      x, y, 30,
      x, y, 60
    );
    glowGradient.addColorStop(0, 'rgba(100, 200, 150, 0.4)');
    glowGradient.addColorStop(1, 'rgba(100, 200, 150, 0)');
    ctx.fillStyle = glowGradient;
    ctx.beginPath();
    ctx.arc(x, y, 60, 0, Math.PI * 2);
    ctx.fill();
    
    // Lily pad base
    ctx.fillStyle = '#1a3a2a';
    ctx.beginPath();
    ctx.ellipse(x, y, 50, 30, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Glowing veins
    ctx.strokeStyle = 'rgba(100, 255, 200, 0.6)';
    ctx.lineWidth = 1.5;
    for (let v = 0; v < 8; v++) {
      const angle = (Math.PI * 2 / 8) * v;
      const innerX = x + Math.cos(angle) * 10;
      const innerY = y + Math.sin(angle) * 10;
      const outerX = x + Math.cos(angle) * 40;
      const outerY = y + Math.sin(angle) * 25;
      ctx.beginPath();
      ctx.moveTo(innerX, innerY);
      ctx.lineTo(outerX, outerY);
      ctx.stroke();
    }
  }

  // Fireflies (animated glowing dots)
  ctx.fillStyle = 'rgba(200, 255, 150, 0.8)';
  for (let i = 0; i < 20; i++) {
    const baseX = (i * 150 + cameraX * 0.2) % (gameCanvas.width + 300);
    const timeOffset = i * 100;
    const x = baseX + Math.sin((Date.now() + timeOffset) * 0.001) * 50;
    const y = 100 + (i * 30) % (gameCanvas.height - 200) + 
              Math.sin((Date.now() + timeOffset) * 0.002) * 40;
    
    // Glow effect
    const glow = ctx.createRadialGradient(
      x, y, 0,
      x, y, 10
    );
    glow.addColorStop(0, 'rgba(200, 255, 150, 0.8)');
    glow.addColorStop(1, 'rgba(200, 255, 150, 0)');
    ctx.fillStyle = glow;
    ctx.beginPath();
    ctx.arc(x, y, 10, 0, Math.PI * 2);
    ctx.fill();
    
    // Core light
    ctx.fillStyle = 'rgba(255, 255, 200, 0.9)';
    ctx.beginPath();
    ctx.arc(x, y, 3, 0, Math.PI * 2);
    ctx.fill();
  }

  // Glowing reeds (background plants)
  for (let i = 0; i < 15; i++) {
    const x = (i * 180 - cameraX * 0.5) % (gameCanvas.width + 400);
    const height = 100 + Math.sin(i) * 40;
    drawGlowingReed(x, gameCanvas.height - 30, height);
  }

  
  // here's a very subtle version of the mushrooms:
  if (false) { // Change to 'true' if you want minimal mushrooms
    ctx.fillStyle = 'rgba(120, 80, 180, 0.15)'; // Much more subtle purple
    for (let i = 0; i < 5; i++) { // Fewer mushrooms
      const x = (i * 500 - cameraX * 0.1) % (gameCanvas.width + 800); // More spread out
      const y = gameCanvas.height - 70;
      const size = 15;
      
      // Just simple caps without glow effect
      ctx.beginPath();
      ctx.arc(x, y - size, size, 0, Math.PI * 2);
      ctx.fill();
    }
  }
}

// Draw glowing reed plant
function drawGlowingReed(x, y, height) {
  // Main stem with glow
  const stemGradient = ctx.createLinearGradient(x, y, x, y - height);
  stemGradient.addColorStop(0, 'rgba(50, 150, 100, 0.8)');
  stemGradient.addColorStop(1, 'rgba(100, 200, 150, 0.4)');
  ctx.strokeStyle = stemGradient;
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.moveTo(x, y);
  ctx.lineTo(x + 5, y - height);
  ctx.stroke();
  
  // Glowing nodes
  for (let i = 0; i < 3; i++) {
    const nodeY = y - (height / 4) * (i + 1);
    const nodeGlow = ctx.createRadialGradient(
      x + 3, nodeY, 0,
      x + 3, nodeY, 8
    );
    nodeGlow.addColorStop(0, 'rgba(100, 255, 200, 0.8)');
    nodeGlow.addColorStop(1, 'rgba(100, 255, 200, 0)');
    ctx.fillStyle = nodeGlow;
    ctx.beginPath();
    ctx.arc(x + 3, nodeY, 8, 0, Math.PI * 2);
    ctx.fill();
  }
  
  // Leaves with subtle glow
  for (let i = 0; i < 4; i++) {
    const leafY = y - (height / 5) * (i + 1);
    const leafLength = 30 + Math.sin(i) * 15;
    
    ctx.strokeStyle = 'rgba(100, 200, 150, 0.6)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(x + 3, leafY);
    ctx.quadraticCurveTo(
      x + 20 + i * 5, 
      leafY - leafLength/2, 
      x + 10, 
      leafY - leafLength
    );
    ctx.stroke();
    
    // Leaf glow
    const leafGlow = ctx.createRadialGradient(
      x + 10, leafY - leafLength/2, 0,
      x + 10, leafY - leafLength/2, leafLength/2
    );
    leafGlow.addColorStop(0, 'rgba(100, 200, 150, 0.2)');
    leafGlow.addColorStop(1, 'rgba(100, 200, 150, 0)');
    ctx.fillStyle = leafGlow;
    ctx.beginPath();
    ctx.moveTo(x + 3, leafY);
    ctx.quadraticCurveTo(
      x + 20 + i * 5, 
      leafY - leafLength/2, 
      x + 10, 
      leafY - leafLength
    );
    ctx.lineTo(x + 3, leafY);
    ctx.fill();
  }
}

function drawCityBackground(cameraX) {
  // Night sky gradient
  const skyGradient = ctx.createLinearGradient(0, 0, 0, gameCanvas.height);
  skyGradient.addColorStop(0, '#0a0a2a');
  skyGradient.addColorStop(1, '#1a1a40');
  ctx.fillStyle = skyGradient;
  ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);

  // Stars
  ctx.fillStyle = 'white';
  for (let i = 0; i < 100; i++) {
    const x = (i * 50 + cameraX * 0.1) % (gameCanvas.width + 200);
    const y = (i * 30) % gameCanvas.height;
    const size = Math.random() * 1.5;
    ctx.fillRect(x, y, size, size);
  }

  // Distant buildings (parallax)
  ctx.fillStyle = '#222244';
  for (let i = 0; i < 15; i++) {
    const width = 80 + Math.sin(i) * 20;
    const height = 100 + Math.cos(i * 0.7) * 50;
    ctx.fillRect(
      i * 150 - cameraX * 0.3, 
      gameCanvas.height - height,
      width, 
      height
    );
  }

  // Closer buildings
  ctx.fillStyle = '#333366';
  for (let i = 0; i < 10; i++) {
    const height = 200 + Math.sin(i) * 40;
    ctx.fillRect(
      i * 200 - cameraX * 0.7, 
      gameCanvas.height - height,
      120, 
      height
    );
  }

  // Windows (yellow lights)
  ctx.fillStyle = 'rgba(255, 215, 0, 0.4)'; // More transparent gold
for (let i = 0; i < 20; i++) { // Fewer windows
  const x = (i * 150 + cameraX * 0.5) % 2000;
  const y = gameCanvas.height - 30 - (Math.floor(i / 4) * 50); // More spaced out
  if (Math.random() > 0.5) { // 50% chance to draw a window
    ctx.fillRect(x, y, 10, 15); // Smaller windows
  }
}
}

function drawVolcanoBackground(cameraX) {
  // Cave gradient (dark red to black)
  const caveGradient = ctx.createLinearGradient(0, 0, 0, gameCanvas.height);
  caveGradient.addColorStop(0, '#3a0a0a');
  caveGradient.addColorStop(1, '#000000');
  ctx.fillStyle = caveGradient;
  ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);

  // Lava river at bottom
  const lavaGradient = ctx.createLinearGradient(0, gameCanvas.height - 50, 0, gameCanvas.height);
  lavaGradient.addColorStop(0, '#ff4500');
  lavaGradient.addColorStop(1, '#ff8c00');
  ctx.fillStyle = lavaGradient;
  ctx.fillRect(0, gameCanvas.height - 30, gameCanvas.width, 30);

  // Lava bubbles
  ctx.fillStyle = '#ff6600';
  for (let i = 0; i < 8; i++) {
    const x = (i * 200 + cameraX * 0.4) % (gameCanvas.width + 300);
    const y = gameCanvas.height - 35 + Math.sin(Date.now() * 0.002 + i) * 3;
    ctx.beginPath();
    ctx.arc(x, y, 10 + Math.sin(Date.now() * 0.001 + i) * 5, 0, Math.PI * 2);
    ctx.fill();
  }

  // Stalactites
  ctx.fillStyle = '#555555';
  for (let i = 0; i < 20; i++) {
    const x = i * 150 - cameraX * 0.6;
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x + 15, 0);
    ctx.lineTo(x + 7, 40 + Math.sin(i) * 20);
    ctx.closePath();
    ctx.fill();
  }
}

function drawAlienBackground(cameraX) {
  // Sky gradient (purple to pink)
  const skyGradient = ctx.createLinearGradient(0, 0, 0, gameCanvas.height);
  skyGradient.addColorStop(0, '#4b0082');
  skyGradient.addColorStop(1, '#ff1493');
  ctx.fillStyle = skyGradient;
  ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);

  // Floating alien orbs
  ctx.fillStyle = 'rgba(0, 255, 255, 0.4)';
  for (let i = 0; i < 6; i++) {
    const x = (i * 250 + cameraX * 0.2) % (gameCanvas.width + 400);
    const y = 100 + Math.sin(Date.now() * 0.001 + i) * 30;
    ctx.beginPath();
    ctx.arc(x, y, 30, 0, Math.PI * 2);
    ctx.fill();
  }

  // Strange plants
  ctx.fillStyle = '#7cfc00';
  for (let i = 0; i < 10; i++) {
    const x = i * 200 - cameraX * 0.5;
    ctx.beginPath();
    ctx.moveTo(x, gameCanvas.height);
    ctx.bezierCurveTo(
      x + 50, gameCanvas.height - 120,
      x - 50, gameCanvas.height - 180,
      x, gameCanvas.height - 220
    );
    ctx.lineWidth = 8;
    ctx.stroke();
  }

  // Twin moons
  ctx.fillStyle = 'rgba(255, 255, 0, 0.7)';
  ctx.beginPath();
  ctx.arc(150 - cameraX * 0.05, 80, 30, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = 'rgba(255, 100, 255, 0.5)';
  ctx.beginPath();
  ctx.arc(300 - cameraX * 0.03, 60, 40, 0, Math.PI * 2);
  ctx.fill();
}
function drawForestBackground(cameraX, weather = "rain") {
  const isSnow = weather === "snow";

  // Sky gradient
  const skyGradient = ctx.createLinearGradient(0, 0, 0, gameCanvas.height);
  skyGradient.addColorStop(0, '#001f27');
  skyGradient.addColorStop(1, '#0d0020');
  ctx.fillStyle = skyGradient;
  ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);

  // ---------- helpers ----------
  // Clip to a given path, then paint a vertical white gradient over its TOP half.
  function overlaySnowForPath(drawPathFn, topY, bottomY) {
    const midY = topY + (bottomY - topY) * 0.55; // how far the snow reaches
    ctx.save();
    drawPathFn();      // define the silhouette
    ctx.clip();        // restrict painting to the silhouette
    const g = ctx.createLinearGradient(0, topY, 0, midY);
    g.addColorStop(0, 'rgba(255,255,255,0.95)');
    g.addColorStop(1, 'rgba(255,255,255,0.05)');
    ctx.fillStyle = g;
    // Big rect‚Äîclip confines it to the tree
    ctx.fillRect(-1e4, topY - 10, 2e4, (midY - topY) + 20);
    ctx.restore();
  }

  // Soften greens slightly under snow (subtle cool tint)
  const forestGreen = isSnow ? '#0fa59c' : '#00a896';
  const pineGreen   = isSnow ? 'rgba(2,195,154,0.85)' : 'rgba(2,195,154,0.7)';

  // ---------- WEATHER: rain (skip if snow) ----------
  if (!isSnow) {
    ctx.strokeStyle = 'rgba(180, 235, 255, 0.4)';
    ctx.lineWidth = 1.2;
    const drops = 80;
    for (let i = 0; i < drops; i++) {
      const x = (i * 25 + cameraX * 0.1) % (gameCanvas.width + 50);
      const prog = (Date.now() * 0.2 + i * 50) % (gameCanvas.height + 100);
      const y = prog - 100;
      if (y > -10 && y < gameCanvas.height) {
        const opacity = Math.min(1, prog / 100) * 0.4;
        const len = 12 + Math.sin(i) * 4;
        ctx.save();
        ctx.globalAlpha = opacity;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x, y + len);
        ctx.stroke();
        ctx.restore();
      }
    }
  }

  // ---------- TREES (three styles), now with proper snow overlays ----------
  const treeTypes = [
    // Type 1: Willow-style canopy blob + trunk
    { draw: (x) => {
      const trunkTopY = gameCanvas.height - 100;
      const trunkW = 24, trunkH = 100;

      // Trunk
      ctx.fillStyle = '#5e503f';
      ctx.fillRect(x, trunkTopY, trunkW, trunkH);

      // Canopy blob (we'll define a single silhouette path)
      const cx = x + trunkW * 0.5;   // canopy center
      const cy = trunkTopY - 35;
      const rx = 58;                 // canopy radii
      const ry = 45;

      // fill canopy
      ctx.fillStyle = forestGreen;
      ctx.beginPath();
      ctx.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2);
      ctx.fill();

      // add a few scallops for texture (same color)
      for (let j = -2; j <= 2; j++) {
        ctx.beginPath();
        ctx.ellipse(cx + j * 18, cy + 8, rx * 0.55, ry * 0.4, 0, 0, Math.PI * 2);
        ctx.fill();
      }

      if (isSnow) {
        // silhouette path for clipping
        const canopyTop = cy - ry - 8;
        const canopyBottom = cy + ry + 4;
        overlaySnowForPath(() => {
          ctx.beginPath();
          ctx.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2);
          for (let j = -2; j <= 2; j++) {
            ctx.ellipse(cx + j * 18, cy + 8, rx * 0.55, ry * 0.4, 0, 0, Math.PI * 2);
          }
        }, canopyTop, canopyBottom);
      }
    }},

    // Type 2: Pine (three stacked triangles) + trunk
    { draw: (x) => {
      const baseY = gameCanvas.height - 120;
      const trunkW = 18, trunkH = 120;

      // Trunk
      ctx.fillStyle = '#4a4e41';
      ctx.fillRect(x, baseY, trunkW, trunkH);

      // Foliage tiers (triangles)
      const tipY = baseY - 62;
      const tiers = [
        { topY: tipY,      left: x - 18, right: x + trunkW + 18, bottomY: baseY + 0  },
        { topY: tipY + 28, left: x - 26, right: x + trunkW + 26, bottomY: baseY + 28 },
        { topY: tipY + 56, left: x - 34, right: x + trunkW + 34, bottomY: baseY + 56 },
      ];

      // draw triangles (fill)
      ctx.fillStyle = pineGreen;
      tiers.forEach(t => {
        ctx.beginPath();
        ctx.moveTo(x + trunkW * 0.5, t.topY);
        ctx.lineTo(t.right, t.bottomY);
        ctx.lineTo(t.left,  t.bottomY);
        ctx.closePath();
        ctx.fill();
      });

      if (isSnow) {
        // combined silhouette of triangles for clipping
        const topMost = tiers[0].topY - 6;
        const bottomMost = tiers[2].bottomY + 4;
        overlaySnowForPath(() => {
          ctx.beginPath();
          tiers.forEach(t => {
            ctx.moveTo(x + trunkW * 0.5, t.topY);
            ctx.lineTo(t.right, t.bottomY);
            ctx.lineTo(t.left,  t.bottomY);
            ctx.closePath();
          });
        }, topMost, bottomMost);
      }
    }},

    // Type 3: Glowing mushroom tree
    { draw: (x) => {
      // Trunk
      ctx.fillStyle = '#69385c';
      ctx.fillRect(x, gameCanvas.height - 80, 15, 80);

      // Cap silhouette
      const capX = x + 7, capY = gameCanvas.height - 100, capR = 30;

      // Cap fill
      ctx.fillStyle = '#ff6b6b';
      ctx.beginPath();
      ctx.arc(capX, capY, capR, 0, Math.PI * 2);
      ctx.fill();

      // Spots
      ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
      for (let j = 0; j < 5; j++) {
        ctx.beginPath();
        ctx.arc(
          capX + Math.cos(j * 1.2) * 20,
          capY + Math.sin(j * 1.2) * 20,
          3 + Math.sin(Date.now() * 0.005 + j) * 2,
          0, Math.PI * 2
        );
        ctx.fill();
      }

      if (isSnow) {
        // Overlay snow on the top half of the cap
        overlaySnowForPath(() => {
          ctx.beginPath();
          ctx.arc(capX, capY, capR + 2, 0, Math.PI * 2);
        }, capY - capR - 4, capY + capR);
      }
    }},
  ];

  // Draw 8 trees with parallax
  for (let i = 0; i < 8; i++) {
    const draw = treeTypes[i % treeTypes.length].draw;
    const x = i * 300 - cameraX * 0.6;
    if (x > -200 && x < gameCanvas.width + 200) draw(x);
  }

  // Foreground foliage
  ctx.fillStyle = 'rgba(0, 168, 150, 0.3)';
  for (let i = 0; i < 40; i++) {
    const x = (i * 100 - cameraX * 0.9) % (gameCanvas.width + 400);
    const h = 30 + Math.sin(i) * 15;
    ctx.beginPath();
    ctx.moveTo(x, gameCanvas.height);
    ctx.lineTo(x + 20, gameCanvas.height - h);
    ctx.lineTo(x - 10, gameCanvas.height - h * 0.7);
    ctx.closePath();
    ctx.fill();
  }

  // ---------- Snowfall overlay (only in snow mode) ----------
  if (isSnow && typeof snowParticles !== 'undefined' && typeof maxSnowParticles !== 'undefined') {
    const INTENSITY   = 0.35; // 35% of pool
    const WIND_X      = 0.12; // gentle right drift
    const SPEED_SCALE = 0.6;  // slower than storm
    const count = Math.floor(maxSnowParticles * INTENSITY);

    for (let i = 0; i < count; i++) {
      const p = snowParticles[i];
      if (!p) continue;

      // Update
      p.y += p.speed * SPEED_SCALE;
      p.x += p.wind * 0.5 + WIND_X;

      // Wrap
      if (p.y > gameCanvas.height) {
        p.y = -10;
        p.x = Math.random() * gameCanvas.width;
      }
      if (p.x > gameCanvas.width + 10) p.x = -10;
      if (p.x < -10) p.x = gameCanvas.width + 10;

      // Draw
      ctx.fillStyle = `rgba(255,255,255,${p.opacity})`;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fill();
    }
  }
}




    function drawProjectileEffects(ctx) {
    for (let i = gameState.particles.length - 1; i >= 0; i--) {
        const p = gameState.particles[i];
        const drawX = p.x - gameState.cameraX;
        const drawY = p.y;

        // === WATER PARTICLES ===
if (p.type === 'water') {
    // Soft glow
    ctx.fillStyle = `rgba(200, 255, 255, ${Math.min(0.8, p.life / 50)})`;
    ctx.beginPath();
    ctx.arc(drawX, drawY, p.radius * 2, 0, Math.PI * 2);
    ctx.fill();
    
    // Main droplet with softer gradient
    const gradient = ctx.createRadialGradient(
        drawX, drawY, 0,
        drawX, drawY, p.radius
    );
    gradient.addColorStop(0, `rgba(255, 255, 255, 0.9)`);   // bright white core
    gradient.addColorStop(0.4, `rgba(170, 220, 255, 0.75)`); // light blue
    gradient.addColorStop(1, `rgba(40, 90, 180, 0.7)`);      // medium-dark blue edge
    
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(drawX, drawY, p.radius, 0, Math.PI * 2);
    ctx.fill();
    
    // Subtle white highlight
    ctx.fillStyle = `rgba(255, 255, 255, 0.6)`;
    ctx.beginPath();
    ctx.arc(
        drawX - p.radius / 3, 
        drawY - p.radius / 3, 
        p.radius / 4, 
        0, 
        Math.PI * 2
    );
    ctx.fill();
    
    // Softer outline
    ctx.strokeStyle = `rgba(20, 40, 120, 0.4)`; 
    ctx.lineWidth = 0.8;
    ctx.beginPath();
    ctx.arc(drawX, drawY, p.radius, 0, Math.PI * 2);
    ctx.stroke();
}
        // In your drawProjectileEffects function:
else if (p.type === 'electric') {
    // Big white-yellow core
    ctx.fillStyle = `rgba(255, 255, 200, 0.9)`;
    ctx.beginPath();
    ctx.arc(drawX, drawY, p.radius * 1.5, 0, Math.PI * 2);
    ctx.fill();
    
    // Bright center
    ctx.fillStyle = `rgba(255, 255, 100, 1)`;
    ctx.beginPath();
    ctx.arc(drawX, drawY, p.radius, 0, Math.PI * 2);
    ctx.fill();
    
    // Glowing aura
    const gradient = ctx.createRadialGradient(
        drawX, drawY, 0,
        drawX, drawY, p.radius * 3
    );
    gradient.addColorStop(0, 'rgba(255, 255, 150, 0.8)');
    gradient.addColorStop(1, 'rgba(255, 200, 50, 0)');
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(drawX, drawY, p.radius * 3, 0, Math.PI * 2);
    ctx.fill();
}
else if (p.type === 'electric-flash') {
    // Flash effect
    const gradient = ctx.createRadialGradient(
        drawX, drawY, 0,
        drawX, drawY, p.radius
    );
    gradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
    gradient.addColorStop(0.7, 'rgba(255, 255, 200, 0.5)');
    gradient.addColorStop(1, 'rgba(255, 200, 100, 0)');
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(drawX, drawY, p.radius, 0, Math.PI * 2);
    ctx.fill();
}
        // === FIRE PARTICLES ===
        else {
            // Glow effect
            ctx.fillStyle = `rgba(255, ${100 + Math.random() * 100}, 0, ${p.life/50})`;
            ctx.beginPath();
            ctx.arc(drawX, drawY, p.radius * 1.5, 0, Math.PI * 2);
            ctx.fill();
            
            // Main particle
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(drawX, drawY, p.radius, 0, Math.PI * 2);
            ctx.fill();
        }

        // Update particle physics
        if (p.gravity) p.vy += p.gravity;
        p.x += p.vx;
        p.y += p.vy;
        
        // Apply special decay for electric particles
        p.life -= (p.decay || 1);
        
        // Remove dead particles
        if (p.life <= 0) {
            gameState.particles.splice(i, 1);
        }
    }
}



    function endLevel() {
      if(gameState.player && gameState.player.lives === 3){ addPoints(SCORE.noDeathBonus); }

      playSfx('level');
      gameState.gameActive = false;
      showScreen(quizScreen);

      // Reset quiz questions for this session
      gameState.quizQuestions = [];

      
      // Get the appropriate question bank based on topic
      let bank = [];
      const topic = gameState.selectedTopic;

      if (topic === "trivia") {
        bank = questionBanks.trivia;
      } else if (topic === "vce") {
        // Hidden lore mapping (not shown in UI):
        // Bubbles (water) -> Year 11 (Units 1 & 2)
        // Spark (electric) -> Unit 3
        // Flame (fire) -> Unit 4
        const elem = gameState.player?.element || "electric";
        if (elem === "water") bank = questionBanks.vce.y11;
        else if (elem === "fire") bank = questionBanks.vce.u4;
        else bank = questionBanks.vce.u3;
      } else {
        bank = questionBanks.trivia;
      }

      // Filter out questions already used in previous levels
      const availableQuestions = bank.filter(q => !gameState.usedQuestions.includes(q));

      // Determine how many questions to use (based on collected brains)
      const maxQuestions = 5;
      const numQuestions = Math.min(gameState.collectedBrains.length, maxQuestions);

      // Select random questions
      for (let i = 0; i < numQuestions; i++) {
        if (availableQuestions.length === 0) break;
        const randomIndex = Math.floor(Math.random() * availableQuestions.length);
        const selected = availableQuestions[randomIndex];
        gameState.quizQuestions.push(selected);
        gameState.usedQuestions.push(selected);
        availableQuestions.splice(randomIndex, 1);
      }

      gameState.score.total = gameState.quizQuestions.length;
      gameState.levelScore.total = gameState.quizQuestions.length;
      gameState.currentQuestion = 0;

      collectedCount.textContent = gameState.collectedBrains.length;
      showQuestion();
    }

    // Show current question
    function showQuestion() {
      updatePointsUI();
      if (gameState.currentQuestion >= gameState.quizQuestions.length) {
        showScoreScreen();
        return;
      }
      
      const question = gameState.quizQuestions[gameState.currentQuestion];
      questionText.textContent = question.question;
      
      optionsContainer.innerHTML = '';
      question.options.forEach((option, index) => {
        const button = document.createElement('button');
        button.className = 'optionBtn';
        button.textContent = option;
        button.dataset.index = index;
        button.addEventListener('click', () => checkAnswer(index, question.answer, button));
        if (isMobile) {
          button.addEventListener('touchstart', () => checkAnswer(index, question.answer, button));
        }
        optionsContainer.appendChild(button);
      });
    }

    // Check if answer is correct
    function checkAnswer(selected, correct, button) {
      // Disable all buttons
      const buttons = optionsContainer.querySelectorAll('.optionBtn');
      buttons.forEach(btn => {
        btn.disabled = true;
        btn.style.cursor = 'default';
      });
      
      // Mark correct and incorrect
      if (selected === correct) {
        button.classList.add('correct');
        playSfx('correct');
        gameState.score.correct++;
        gameState.levelScore.correct++;
        addPoints(SCORE.correct);

        gameState.overall.correct++;
      } else {
        button.classList.add('incorrect');
        playSfx('wrong');
        // Also highlight correct answer
        buttons[correct].classList.add('correct');
      }
      
      // Move to next question after delay
      setTimeout(() => {
        gameState.currentQuestion++;
        showQuestion();
      }, 1500);
    }

    function showScoreScreen() {
      showScreen(scoreScreen);

      const correct = gameState.levelScore.correct;
      const total = gameState.levelScore.total;
      const percentage = Math.round((correct / total) * 100);
      gameState.levelResults.push({ level: gameState.currentLevel, correct, total, percentage });
      scoreSummary.textContent = `You scored ${correct}/${total} (${percentage}%) on the ${gameState.levels[gameState.currentLevel-1].name} quiz!`;

      if (gameState.currentLevel === 10) {
        playSfx('win');
        // Final level: show a "Game Complete" button instead of "Next Level"
        nextBtn.style.display = 'inline-block';
        nextBtn.textContent = 'üèÅ Game Complete';
      } else {
        nextBtn.style.display = 'inline-block';
        nextBtn.textContent = 'Next Level';
      }
    }

    // Retry current level
    function retryLevel() {
      showScreen(gameCanvas);
      setupLevel(gameState.currentLevel);
      gameState.gameActive = true;
      requestAnimationFrame(gameLoop);
    }

    // Go to next level
    function nextLevel() {
       if (gameState.currentLevel < 10) {
        setupLevel(gameState.currentLevel + 1);
        showScreen(gameCanvas);
        gameState.gameActive = true;
        requestAnimationFrame(gameLoop);
      } else {
        showFinalScreen();
      }
    }

    // Show final screen
    function showFinalScreen() {
      showScreen(finalScreen);

      const scoreStr = `${gameState.overall.correct}/50`;
      const rank = getRank(gameState.points);
      finalText.innerHTML =
        `Tadpole made it home to the pond üê∏üèÅ<br><br>
        <b>Rank:</b> ${rank.emoji} ${rank.name}<br>
        <b>Game Score:</b> ${gameState.points}<br>
        <b>Quiz Score:</b> ${gameState.overall.correct}/${gameState.overall.total}<br><br>
        Tap <b>Beat My Score</b> to challenge a friend.<br><br>
        Created by Aaron Gillespie ‚Äî good luck with your studies!`;
}

    // Restart game
    function restartGame() {
      showScreen(startScreen);
    }

    // Reset game state
    function resetGameState() {
      gameState.points = 0;
      gameState.levelPoints = 0;
      gameState.levelStartPoints = 0;
      gameState.currentLevel = 1;
      gameState.levels.forEach(level => {
        level.collected = 0;
      });
      // Reset scoring
      gameState.overall.correct = 0;
      gameState.overall.total = 50; // 10 levels √ó 5 questions
      gameState.levelScore = { correct: 0, total: 0 };
      gameState.score = { correct: 0, total: 0 }; // kept for backward compatibility in a few UI spots
    }

    // Handle key down
    function handleKeyDown(e) {
      if (!gameState.gameActive) return;
      
      if (e.key === 'ArrowLeft' || e.key === 'a') {
        gameState.keys.left = true;
      } else if (e.key === 'ArrowRight' || e.key === 'd') {
        gameState.keys.right = true;
      } else if ((e.key === 'ArrowUp' || e.key === 'w' || e.key === ' ') && gameState.player.grounded) {
        gameState.keys.up = true;
      } else if (e.key === 'r' || e.key === 'R') {
        gameState.keys.r = true;
      } else if (e.key === 'f' || e.key === 'F') {
        gameState.keys.shoot = true;
      }
    }

    // Handle key up
    function handleKeyUp(e) {
      if (e.key === 'ArrowLeft' || e.key === 'a') {
        gameState.keys.left = false;
      } else if (e.key === 'ArrowRight' || e.key === 'd') {
        gameState.keys.right = false;
      } else if (e.key === 'ArrowUp' || e.key === 'w' || e.key === ' ') {
        gameState.keys.up = false;
      } else if (e.key === 'r' || e.key === 'R') {
        gameState.keys.r = false;
      } else if (e.key === 'f' || e.key === 'F') {
        gameState.keys.shoot = false;
      }
    }

    // Question Banks
    const questionBanks = {
  "trivia": [
    {
      "question": "Which molecule is the primary energy currency of cells?",
      "options": [
        "ATP",
        "DNA",
        "Glucose",
        "Cholesterol"
      ],
      "answer": 0,
      "explanation": "ATP stores and transfers energy for cellular work."
    },
    {
      "question": "Which organelle is responsible for most ATP production in aerobic respiration?",
      "options": [
        "Ribosome",
        "Mitochondrion",
        "Golgi apparatus",
        "Lysosome"
      ],
      "answer": 1
    },
    {
      "question": "What is the correct order of biological organisation?",
      "options": [
        "Organ ‚Üí Tissue ‚Üí Cell ‚Üí Organ system",
        "Cell ‚Üí Tissue ‚Üí Organ ‚Üí Organ system",
        "Tissue ‚Üí Cell ‚Üí Organ ‚Üí Organ system",
        "Cell ‚Üí Organ ‚Üí Tissue ‚Üí Organ system"
      ],
      "answer": 1
    },
    {
      "question": "Which process produces gametes in humans?",
      "options": [
        "Mitosis",
        "Meiosis",
        "Binary fission",
        "Budding"
      ],
      "answer": 1
    },
    {
      "question": "Which is a feature of living things?",
      "options": [
        "They always move quickly",
        "They reproduce (at some life stage)",
        "They must be multicellular",
        "They are always green"
      ],
      "answer": 1
    },
    {
      "question": "What is the role of enzymes?",
      "options": [
        "Speed up chemical reactions",
        "Store genetic information",
        "Carry oxygen",
        "Make cell walls"
      ],
      "answer": 0
    },
    {
      "question": "Which macromolecule is made of amino acids?",
      "options": [
        "Carbohydrate",
        "Lipid",
        "Protein",
        "Nucleic acid"
      ],
      "answer": 2
    },
    {
      "question": "DNA is best described as a molecule that‚Ä¶",
      "options": [
        "Stores hereditary information",
        "Provides immediate energy",
        "Forms cell membranes",
        "Breaks down toxins"
      ],
      "answer": 0
    },
    {
      "question": "Which is a correct example of a consumer in a food web?",
      "options": [
        "Grass",
        "Algae",
        "Fungus",
        "Kangaroo"
      ],
      "answer": 3
    },
    {
      "question": "Photosynthesis converts light energy into‚Ä¶",
      "options": [
        "Heat energy",
        "Chemical energy stored in glucose",
        "Kinetic energy",
        "Sound energy"
      ],
      "answer": 1
    },
    {
      "question": "Which gas is a reactant in aerobic respiration?",
      "options": [
        "Oxygen",
        "Nitrogen",
        "Carbon monoxide",
        "Helium"
      ],
      "answer": 0
    },
    {
      "question": "Which is NOT a type of nucleic acid?",
      "options": [
        "DNA",
        "RNA",
        "Starch",
        "mRNA"
      ],
      "answer": 2
    },
    {
      "question": "Homeostasis refers to‚Ä¶",
      "options": [
        "Rapid growth",
        "Stable internal conditions",
        "Mutation rate",
        "Cell division"
      ],
      "answer": 1
    },
    {
      "question": "Which is an example of a pathogen?",
      "options": [
        "A virus",
        "A ribosome",
        "A mitochondrion",
        "A neuron"
      ],
      "answer": 0
    },
    {
      "question": "A community is‚Ä¶",
      "options": [
        "All organisms of one species",
        "All living and non-living things",
        "All populations of different species in an area",
        "Only producers in an ecosystem"
      ],
      "answer": 2
    },
    {
      "question": "Which structure controls what enters and exits the cell?",
      "options": [
        "Cell wall",
        "Cell membrane",
        "Nucleus",
        "Cytoplasm"
      ],
      "answer": 1
    },
    {
      "question": "In a typical enzyme reaction, the substrate binds to the‚Ä¶",
      "options": [
        "Active site",
        "Nucleolus",
        "Cell wall",
        "Rough ER"
      ],
      "answer": 0
    },
    {
      "question": "Which is a product of photosynthesis?",
      "options": [
        "Oxygen",
        "Carbon dioxide",
        "Lactic acid",
        "Ammonia"
      ],
      "answer": 0
    },
    {
      "question": "Which term describes a change in DNA sequence?",
      "options": [
        "Mutation",
        "Translation",
        "Homeostasis",
        "Diffusion"
      ],
      "answer": 0
    },
    {
      "question": "Natural selection requires‚Ä¶",
      "options": [
        "Variation and differential survival",
        "No genetic variation",
        "All offspring survive",
        "A perfect environment"
      ],
      "answer": 0
    },
    {
      "question": "Water is important in cells mainly because it‚Ä¶",
      "options": [
        "Is a good solvent",
        "Stores DNA",
        "Is always acidic",
        "Cannot form bonds"
      ],
      "answer": 0
    },
    {
      "question": "Which is a correct example of a disaccharide?",
      "options": [
        "Glucose",
        "Starch",
        "Sucrose",
        "Glycogen"
      ],
      "answer": 2
    },
    {
      "question": "Which is the main function of the ribosome?",
      "options": [
        "Protein synthesis",
        "ATP synthesis",
        "Lipid synthesis",
        "DNA replication"
      ],
      "answer": 0
    },
    {
      "question": "What is osmosis?",
      "options": [
        "Diffusion of water across a membrane",
        "Movement of ions using ATP",
        "Breakdown of glucose",
        "Cell division"
      ],
      "answer": 0
    },
    {
      "question": "Which blood cell type helps fight infection?",
      "options": [
        "Red blood cell",
        "Platelet",
        "White blood cell",
        "Neuron"
      ],
      "answer": 2
    },
    {
      "question": "A key difference between prokaryotic and eukaryotic cells is that eukaryotes‚Ä¶",
      "options": [
        "Have DNA",
        "Have ribosomes",
        "Have a nucleus",
        "Have a cell membrane"
      ],
      "answer": 2
    },
    {
      "question": "Which is a lipid?",
      "options": [
        "Starch",
        "Triglyceride",
        "Hemoglobin",
        "DNA"
      ],
      "answer": 1
    },
    {
      "question": "A producer gets energy mainly by‚Ä¶",
      "options": [
        "Eating consumers",
        "Photosynthesis or chemosynthesis",
        "Decomposition",
        "Parasitism"
      ],
      "answer": 1
    },
    {
      "question": "Biodiversity refers to‚Ä¶",
      "options": [
        "Only the number of predators",
        "The variety of living organisms",
        "Only the number of plants",
        "The age of an ecosystem"
      ],
      "answer": 1
    },
    {
      "question": "The nucleus contains‚Ä¶",
      "options": [
        "Chlorophyll",
        "Chromosomes",
        "Cell walls",
        "Enzymes for digestion"
      ],
      "answer": 1
    },
    {
      "question": "The movement of particles from high to low concentration is‚Ä¶",
      "options": [
        "Diffusion",
        "Condensation",
        "Combustion",
        "Transcription"
      ],
      "answer": 0
    },
    {
      "question": "Meiosis produces cells that are‚Ä¶",
      "options": [
        "Diploid and identical",
        "Haploid and genetically varied",
        "Diploid and varied",
        "Haploid and identical"
      ],
      "answer": 1
    },
    {
      "question": "A homologous chromosome pair consists of‚Ä¶",
      "options": [
        "Two identical chromatids",
        "Two chromosomes with the same genes",
        "Two random chromosomes",
        "Only sex chromosomes"
      ],
      "answer": 1
    },
    {
      "question": "An allele is‚Ä¶",
      "options": [
        "A type of cell",
        "A version of a gene",
        "A type of protein",
        "A sugar molecule"
      ],
      "answer": 1
    },
    {
      "question": "Which is an example of an abiotic factor?",
      "options": [
        "Bacteria",
        "Temperature",
        "Grass",
        "Predator"
      ],
      "answer": 1
    }
  ],
  "cell": [
    {
      "question": "What is the main role of the rough endoplasmic reticulum?",
      "options": [
        "Lipid synthesis",
        "Protein synthesis for export",
        "DNA replication",
        "ATP production"
      ],
      "answer": 1
    },
    {
      "question": "The Golgi apparatus mainly‚Ä¶",
      "options": [
        "Packages and modifies proteins",
        "Carries out photosynthesis",
        "Stores DNA",
        "Digests toxins"
      ],
      "answer": 0
    },
    {
      "question": "Vesicles in the secretory pathway mainly‚Ä¶",
      "options": [
        "Carry proteins between organelles",
        "Make ATP",
        "Copy DNA",
        "Break down starch"
      ],
      "answer": 0
    },
    {
      "question": "Which structure is present in plant cells but not animal cells?",
      "options": [
        "Cell membrane",
        "Mitochondrion",
        "Cell wall",
        "Ribosome"
      ],
      "answer": 2
    },
    {
      "question": "A selectively permeable membrane means‚Ä¶",
      "options": [
        "Nothing can cross",
        "Only some substances cross",
        "Only water crosses",
        "Only proteins cross"
      ],
      "answer": 1
    },
    {
      "question": "Mitosis results in‚Ä¶",
      "options": [
        "Two genetically identical daughter cells",
        "Four genetically different cells",
        "Two haploid cells",
        "One larger cell"
      ],
      "answer": 0
    },
    {
      "question": "During interphase, a cell primarily‚Ä¶",
      "options": [
        "Divides",
        "Grows and replicates DNA",
        "Forms gametes",
        "Undergoes translation"
      ],
      "answer": 1
    },
    {
      "question": "Apoptosis is‚Ä¶",
      "options": [
        "Uncontrolled cell division",
        "Programmed cell death",
        "A type of mutation",
        "A form of diffusion"
      ],
      "answer": 1
    },
    {
      "question": "Stem cells are important because they can‚Ä¶",
      "options": [
        "Only make red blood cells",
        "Differentiate into specialised cells",
        "Only undergo meiosis",
        "Only exist in plants"
      ],
      "answer": 1
    },
    {
      "question": "Which organelle contains digestive enzymes?",
      "options": [
        "Lysosome",
        "Nucleolus",
        "Ribosome",
        "Centrosome"
      ],
      "answer": 0
    },
    {
      "question": "The fluid inside a chloroplast where the Calvin cycle occurs is the‚Ä¶",
      "options": [
        "Thylakoid",
        "Stroma",
        "Matrix",
        "Cytosol"
      ],
      "answer": 1
    },
    {
      "question": "In a phospholipid bilayer, the hydrophobic parts are the‚Ä¶",
      "options": [
        "Phosphate heads",
        "Fatty acid tails",
        "Carbohydrate chains",
        "Proteins"
      ],
      "answer": 1
    },
    {
      "question": "Membrane proteins can function as‚Ä¶",
      "options": [
        "Enzymes and transporters",
        "Only pigments",
        "Only storage molecules",
        "Only DNA"
      ],
      "answer": 0
    },
    {
      "question": "Active transport requires‚Ä¶",
      "options": [
        "No energy",
        "ATP and membrane proteins",
        "Only diffusion",
        "Only osmosis"
      ],
      "answer": 1
    },
    {
      "question": "Exocytosis is‚Ä¶",
      "options": [
        "Cell swallowing solids",
        "Vesicles fusing with membrane to release contents",
        "Water moving across membrane",
        "DNA replication"
      ],
      "answer": 1
    },
    {
      "question": "Endocytosis is‚Ä¶",
      "options": [
        "Protein synthesis",
        "Cell taking materials in via vesicles",
        "ATP production",
        "Glucose breakdown"
      ],
      "answer": 1
    },
    {
      "question": "A major function of the nucleus is to‚Ä¶",
      "options": [
        "Control cell activities via gene expression",
        "Make ATP",
        "Store lipids",
        "Digest waste"
      ],
      "answer": 0
    },
    {
      "question": "Ribosomes can be found‚Ä¶",
      "options": [
        "Only in the nucleus",
        "Only in mitochondria",
        "Free in cytosol or on rough ER",
        "Only in chloroplasts"
      ],
      "answer": 2
    },
    {
      "question": "The cytoskeleton helps cells by‚Ä¶",
      "options": [
        "Providing structure and transport tracks",
        "Storing DNA",
        "Producing glucose",
        "Breaking down toxins"
      ],
      "answer": 0
    },
    {
      "question": "Cellular respiration begins with glycolysis in the‚Ä¶",
      "options": [
        "Mitochondrial matrix",
        "Cytosol",
        "Nucleus",
        "Golgi"
      ],
      "answer": 1
    }
  ],
  "vce": {
    "y11": [
      {
        "question": "A negative feedback loop typically‚Ä¶",
        "options": [
          "Amplifies change",
          "Reduces deviation from a set point",
          "Stops all responses",
          "Only occurs in plants"
        ],
        "answer": 1
      },
      {
        "question": "Which hormone lowers blood glucose by promoting uptake into cells?",
        "options": [
          "Glucagon",
          "Insulin",
          "Adrenaline",
          "Melatonin"
        ],
        "answer": 1
      },
      {
        "question": "Apoptosis is important because it‚Ä¶",
        "options": [
          "Prevents all mutations",
          "Removes damaged/unneeded cells",
          "Always causes cancer",
          "Stops immune responses"
        ],
        "answer": 1
      },
      {
        "question": "Natural selection acts directly on‚Ä¶",
        "options": [
          "Genotypes only",
          "Phenotypes in an environment",
          "Mutations only",
          "Ecosystems only"
        ],
        "answer": 1
      },
      {
        "question": "Gene flow refers to‚Ä¶",
        "options": [
          "Movement of alleles between populations",
          "Formation of proteins",
          "DNA replication",
          "Speciation"
        ],
        "answer": 0
      },
      {
        "question": "Genetic drift is most significant in‚Ä¶",
        "options": [
          "Large populations",
          "Small populations",
          "Only plants",
          "Only predators"
        ],
        "answer": 1
      },
      {
        "question": "A phylogenetic tree shows‚Ä¶",
        "options": [
          "Energy flow",
          "Evolutionary relationships",
          "Weather patterns",
          "Protein folding"
        ],
        "answer": 1
      },
      {
        "question": "Biodiversity includes variation at the level of‚Ä¶",
        "options": [
          "Only species",
          "Genes, species and ecosystems",
          "Only ecosystems",
          "Only genes"
        ],
        "answer": 1
      },
      {
        "question": "An adaptation is best defined as‚Ä¶",
        "options": [
          "A learned behaviour",
          "A heritable feature that improves survival/reproduction",
          "Any change in an organism",
          "A random choice"
        ],
        "answer": 1
      },
      {
        "question": "In a scientific investigation, a valid control helps‚Ä¶",
        "options": [
          "Increase bias",
          "Provide a comparison baseline",
          "Change two variables",
          "Remove data"
        ],
        "answer": 1
      }
    ],
    "u3": [
      {
        "question": "A codon is‚Ä¶",
        "options": [
          "A triplet of DNA bases in a chromosome",
          "A triplet of mRNA bases that codes for an amino acid or stop",
          "A protein",
          "A lipid"
        ],
        "answer": 1
      },
      {
        "question": "RNA processing in eukaryotes includes‚Ä¶",
        "options": [
          "Removing introns and joining exons",
          "Adding amino acids",
          "Copying proteins",
          "Breaking chromosomes"
        ],
        "answer": 0
      },
      {
        "question": "Translation occurs at the‚Ä¶",
        "options": [
          "Nucleus",
          "Ribosome",
          "Golgi",
          "Cell membrane"
        ],
        "answer": 1
      },
      {
        "question": "The anticodon is found on‚Ä¶",
        "options": [
          "mRNA",
          "tRNA",
          "rRNA",
          "DNA"
        ],
        "answer": 1
      },
      {
        "question": "An allosteric inhibitor binds‚Ä¶",
        "options": [
          "The active site",
          "A different site causing shape change",
          "DNA",
          "ATP"
        ],
        "answer": 1
      },
      {
        "question": "Photosynthesis light-dependent reactions occur in the‚Ä¶",
        "options": [
          "Stroma",
          "Thylakoid membranes",
          "Cytosol",
          "Nucleus"
        ],
        "answer": 1
      },
      {
        "question": "In aerobic respiration, most ATP is produced during‚Ä¶",
        "options": [
          "Glycolysis",
          "Krebs cycle",
          "Electron transport chain",
          "Fermentation"
        ],
        "answer": 2
      },
      {
        "question": "A common bioethical approach involves‚Ä¶",
        "options": [
          "Ignoring evidence",
          "Weighing benefits/risks and considering values",
          "Only following emotions",
          "Avoiding discussion"
        ],
        "answer": 1
      },
      {
        "question": "The genetic code is described as degenerate because‚Ä¶",
        "options": [
          "Most amino acids are coded by more than one codon",
          "Each codon codes for many amino acids",
          "DNA has extra bases",
          "Proteins have extra amino acids"
        ],
        "answer": 0
      },
      {
        "question": "The start codon on mRNA is typically‚Ä¶",
        "options": [
          "UAA",
          "AUG",
          "UGA",
          "UAG"
        ],
        "answer": 1
      }
    ],
    "u4": [
      {
        "question": "The first line of defence includes‚Ä¶",
        "options": [
          "Antibodies",
          "Skin and mucous membranes",
          "B cells only",
          "Memory cells"
        ],
        "answer": 1
      },
      {
        "question": "Phagocytosis is carried out by‚Ä¶",
        "options": [
          "Red blood cells",
          "Phagocytes (e.g., macrophages)",
          "Platelets",
          "Neurons"
        ],
        "answer": 1
      },
      {
        "question": "The main role of helper T cells is to‚Ä¶",
        "options": [
          "Destroy infected cells directly",
          "Activate B cells and other immune cells",
          "Produce antibodies",
          "Digest pathogens"
        ],
        "answer": 1
      },
      {
        "question": "Antibodies are produced by‚Ä¶",
        "options": [
          "Plasma cells",
          "Red blood cells",
          "Neutrons",
          "Platelets"
        ],
        "answer": 0
      },
      {
        "question": "Active immunity results from‚Ä¶",
        "options": [
          "Receiving antibodies",
          "Producing your own antibodies after exposure/vaccination",
          "No immune response",
          "Only antibiotics"
        ],
        "answer": 1
      },
      {
        "question": "A vaccine aims to‚Ä¶",
        "options": [
          "Cause disease",
          "Stimulate an immune response and memory",
          "Remove all white blood cells",
          "Stop mutation"
        ],
        "answer": 1
      },
      {
        "question": "Herd immunity occurs when‚Ä¶",
        "options": [
          "Only one person is immune",
          "Enough individuals are immune to reduce spread",
          "Everyone is infected",
          "Only animals are immune"
        ],
        "answer": 1
      },
      {
        "question": "An antigen is best described as‚Ä¶",
        "options": [
          "Any ATP molecule",
          "A molecule recognised by the immune system",
          "A type of ribosome",
          "A DNA polymerase"
        ],
        "answer": 1
      },
      {
        "question": "Active vs passive immunity differs because active immunity‚Ä¶",
        "options": [
          "Involves memory cell formation",
          "Is always short-lived",
          "Cannot be from vaccines",
          "Uses antibiotics"
        ],
        "answer": 0
      },
      {
        "question": "Managing disease includes strategies such as‚Ä¶",
        "options": [
          "Ignoring outbreaks",
          "Vaccination, hygiene and surveillance",
          "Stopping all movement forever",
          "Eliminating all microbes"
        ],
        "answer": 1
      }
    ]
  }
};
    // Initialize the game when page loads
    window.addEventListener('load', init);
  </script>

<div id="tt2-footer">
    <a href="https://1strankbiology.com/" target="_blank" rel="noopener noreferrer">
      <img src="https://svkhhnulgictmdvqvwte.supabase.co/storage/v1/object/public/blacklogo/Logo%20Black.png" alt="1st Rank Biology" loading="lazy">
    </a>
  </div>

</body>
</html>